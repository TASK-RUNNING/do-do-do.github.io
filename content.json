{"meta":{"title":"Melville's blog","subtitle":"个人博客","description":"改革春风吹满地","author":"Melville","url":"https://melville.club"},"pages":[{"title":"404","date":"2019-01-07T08:42:26.000Z","updated":"2019-01-07T08:45:43.446Z","comments":true,"path":"404/index.html","permalink":"https://melville.club/404/index.html","excerpt":"","text":"&lt;!DOCTYPE HTML&gt;"},{"title":"","date":"2018-09-05T07:25:14.000Z","updated":"2019-01-07T08:59:37.777Z","comments":false,"path":"about/index.html","permalink":"https://melville.club/about/index.html","excerpt":"","text":"为中华之崛起而读书"},{"title":"","date":"2018-09-05T07:20:09.000Z","updated":"2019-01-20T09:59:10.308Z","comments":false,"path":"categories/index.html","permalink":"https://melville.club/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-09-05T07:22:10.000Z","updated":"2019-01-20T09:58:53.662Z","comments":false,"path":"tags/index.html","permalink":"https://melville.club/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-01-23T02:35:17.000Z","updated":"2019-01-23T02:43:32.090Z","comments":false,"path":"milestone/index.html","permalink":"https://melville.club/milestone/index.html","excerpt":"","text":"里程碑 3. 2019年1月8日 1将主题版本升级。 2. 2019年1月7日 1给博客新增404公益界面。 1. 2018年9月4日 1新建博客"},{"title":"","date":"2019-01-07T07:26:50.000Z","updated":"2019-01-21T06:59:08.145Z","comments":true,"path":"message/index.html","permalink":"https://melville.club/message/index.html","excerpt":"","text":"留言板 有问题，多沟通，欢迎留言~~"}],"posts":[{"title":"坚持做一件事_20190125","slug":"坚持做一件事-20190125","date":"2019-01-25T02:56:01.000Z","updated":"2019-01-25T07:39:03.933Z","comments":true,"path":"/posts/a-20190125-105601.html","link":"","permalink":"https://melville.club/posts/a-20190125-105601.html","excerpt":"","text":"如果当时坚持每天锻炼，现在的自己应该更健康吧； 如果当时坚持每天读书，现在的自己应该更有气质了吧； 如果当时坚持每天学习PS，现在的自己应该已经成为PS高手了吧； 如果当时坚持每天学习英语，现在的自己应该已经可以读懂英文版技术文档了吧； 如果当时坚持每天学习Linux内核设计，现在的自己应该更容易开发Linux驱动了吧； 如果。。。。。。 如果当时这些都坚持下来，现在的自己应该很优秀了吧； 可是我什么都没坚持下来，什么都半途而废，依旧是个让自己都讨厌的垃圾。 如果我已经是大半截身子入土的人，会不会骂自己年轻时不努力？会不会祈求上天再给我一次重来的机会？我会好好学习，努力改变自己？","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"https://melville.club/categories/生活感悟/"}],"tags":[{"name":"坚持","slug":"坚持","permalink":"https://melville.club/tags/坚持/"},{"name":"生活","slug":"生活","permalink":"https://melville.club/tags/生活/"}]},{"title":"Linux查看端口号","slug":"Linux查看端口号","date":"2019-01-23T02:20:22.000Z","updated":"2019-01-23T02:24:52.154Z","comments":true,"path":"/posts/a-20190123-102022.html","link":"","permalink":"https://melville.club/posts/a-20190123-102022.html","excerpt":"","text":"查看某一端口的占用情况1lsof -i:端口号 显示系统端口使用情况 1netstat -anp","categories":[{"name":"Linux","slug":"Linux","permalink":"https://melville.club/categories/Linux/"}],"tags":[{"name":"端口号","slug":"端口号","permalink":"https://melville.club/tags/端口号/"}]},{"title":"opendir、readdir、rewinddir、closedir、telldir、seekdir、stat函数和DIR、dirent、stat结构体详解","slug":"opendir、readdir、rewinddir、closedir、telldir、seekdir、stat函数和DIR、dirent、stat结构体详解","date":"2019-01-23T01:57:55.000Z","updated":"2019-01-23T02:46:29.251Z","comments":true,"path":"/posts/a-20190123-095755.html","link":"","permalink":"https://melville.club/posts/a-20190123-095755.html","excerpt":"1. opendir()123456789101112131415161718192021222324252627282930// 头文件#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;// 函数原型DIR* opendir (constchar * path );// 功能：打开一个目录// 返回值：成功则返回DIR*型态的目录流, 打开失败则返回NULL.// DIR结构体：struct __dirstream&#123; void *__fd; char *__data; int __entry_data; char *__ptr; int __entry_ptr; size_t __allocation; size_t __size; __libc_lock_define (, __lock)&#125;;typedef struct __dirstream DIR;// 此结构体一般被以下函数使用：struct dirent *readdir(DIR *dp);void rewinddir(DIR *dp);int closedir(DIR *dp);long telldir(DIR *dp);void seekdir(DIR *dp,long loc);","text":"1. opendir()123456789101112131415161718192021222324252627282930// 头文件#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;// 函数原型DIR* opendir (constchar * path );// 功能：打开一个目录// 返回值：成功则返回DIR*型态的目录流, 打开失败则返回NULL.// DIR结构体：struct __dirstream&#123; void *__fd; char *__data; int __entry_data; char *__ptr; int __entry_ptr; size_t __allocation; size_t __size; __libc_lock_define (, __lock)&#125;;typedef struct __dirstream DIR;// 此结构体一般被以下函数使用：struct dirent *readdir(DIR *dp);void rewinddir(DIR *dp);int closedir(DIR *dp);long telldir(DIR *dp);void seekdir(DIR *dp,long loc); 2. readdir()12345678910111213141516171819// 头文件#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;// 函数原型struct dirent* readdir(DIR* dp); /* 需要循环读取dp中的文件和目录，每读取一个文件或目录都返回一个dirent结构体指针 */// 功能：读取目录// 返回值：dirent结构体指针// dirent结构体struct dirent&#123; long d_ino; /* inode number 索引节点号 */ off_t d_off; /* offset to this dirent 在目录文件中的偏移 */ unsigned short d_reclen; /* length of this d_name 文件名长 */ unsigned char d_type; /* the type of d_name 文件类型 */ char d_name [NAME_MAX+1]; /* file name (null-terminated) 文件名，最长255字符 */&#125; 3. rewinddir()12345678// 头文件#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;// 函数原型void rewinddir(DIR *dp);// 功能：用来设置参数dp目录流目前的读取位置为原来开头的读取位置 4. closedir()123456789// 头文件#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;// 函数原型int closedir(DIR*dp);// 功能：关闭参数dp所指的目录流// 返回值：关闭成功则返回0,，失败返回-1 5. telldir()123456789// 头文件#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;// 函数原型long inttelldir(DIR *dp);// 功能：获取当前dp位置// 返回值：返回目录流dp的当前位置，此返回值代表距离目录文件开头的偏移量，有错误发生时返回-1 6. seekdir()12345678// 头文件#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;// 函数原型void seekdir(DIR *dp,long int loc);// 功能：用来设置参数dp目录流当前的读取位置，在调用readdir()时便从此新位置开始读取。参数loc代表距离目录文件开头的偏移量。 7. stat()1234567891011121314151617181920212223242526// 头文件#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;// 函数原型int stat(const char *file_name,struct stat *buf);// 功能：通过文件名file_name获取文件信息，并保存在buf所指的结构体stat中// 返回值：执行成功则返回0，失败返回-1// stat结构体：struct stat &#123; mode_t st_mode; //文件访问权限 ino_t st_ino; //索引节点号 dev_t st_dev; //文件使用的设备号 dev_t st_rdev; //设备文件的设备号 nlink_t st_nlink; //文件的硬连接数 uid_t st_uid; //所有者用户识别号 gid_t st_gid; //组识别号 off_t st_size; //以字节为单位的文件容量 time_t st_atime; //最后一次访问该文件的时间 time_t st_mtime; //最后一次修改该文件的时间 time_t st_ctime; //最后一次改变该文件状态的时间 blksize_t st_blksize; //包含该文件的磁盘块的大小 blkcnt_t st_blocks; //该文件所占的磁盘块&#125;;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://melville.club/categories/Linux/"},{"name":"编程语言","slug":"Linux/编程语言","permalink":"https://melville.club/categories/Linux/编程语言/"}],"tags":[{"name":"结构体","slug":"结构体","permalink":"https://melville.club/tags/结构体/"},{"name":"dir","slug":"dir","permalink":"https://melville.club/tags/dir/"}]},{"title":"Beyond Compare4 激活码","slug":"Beyond-Compare4-激活码","date":"2019-01-21T02:10:25.000Z","updated":"2019-01-21T02:14:18.747Z","comments":true,"path":"/posts/a-20190121-101025.html","link":"","permalink":"https://melville.club/posts/a-20190121-101025.html","excerpt":"","text":"亲测可用，我的版本是 4.2.9 123456w4G-in5u3SH75RoB3VZIX8htiZgw4ELilwvPcHAIQWfwfXv5n0IHDp5hv1BM3+H1XygMtiE0-JBgacjE9tz33sIh542EmsGs1yg638UxVfmWqNLqu-Zw91XxNEiZF7DC7-iV1XbSfsgxI8Tvqr-ZMTxlGCJU+2YLveAc-YXs8ciRTtssts7leEbJ979H5v+G0sw-FwP9bjvE4GCJ8oj+jtlp7wFmpVdzovEhv5Vg3dMqhqTiQHKfmHjYbb0o5OUxq0jOWxg5NKim9dhCVF+avO6mDeRNcOYpl7BatIcd6tsiwdhHKRnyGshyVEjSgRCRY11IgyvdRPnbW8UOVULuTE","categories":[{"name":"工具","slug":"工具","permalink":"https://melville.club/categories/工具/"}],"tags":[{"name":"Beyond Compare4","slug":"Beyond-Compare4","permalink":"https://melville.club/tags/Beyond-Compare4/"},{"name":"激活","slug":"激活","permalink":"https://melville.club/tags/激活/"},{"name":"注册","slug":"注册","permalink":"https://melville.club/tags/注册/"}]},{"title":"hexo站点配置+next主题配置（二）","slug":"hexo站点配置-next主题配置-之二","date":"2019-01-15T07:32:00.000Z","updated":"2019-01-20T09:07:18.976Z","comments":true,"path":"/posts/a-2019-01-15-15-32-00.html","link":"","permalink":"https://melville.club/posts/a-2019-01-15-15-32-00.html","excerpt":"hexo站点配置+next主题配置（一） 3.17 设置RSS先安装 hexo-generator-feed 插件。在站点根目录打开 Git Bash Here ，安装插件： 1npm install --save hexo-generator-feed 打开 站点配置文件 ，添加插件 123# ExtensionsPlugins: - hexo-generate-feed","text":"hexo站点配置+next主题配置（一） 3.17 设置RSS先安装 hexo-generator-feed 插件。在站点根目录打开 Git Bash Here ，安装插件： 1npm install --save hexo-generator-feed 打开 站点配置文件 ，添加插件 123# ExtensionsPlugins: - hexo-generate-feed 打开 主题配置文件 ，修改 rss： 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 3.18 侧边栏友情链接打开 主题配置文件 ，搜索 links_icon ，根据自己的需要添加友情链接，也可以把标题换成 推荐阅读： 12345678# Blog rollslinks_icon: link # 图标links_title: 友情链接 # 标题links_layout: block#links_layout: inlinelinks: #Title1: http://example1.com #Title2: http://example2.com 3.19 增加背景动画next主题提供了四种背景动画，想使用哪一种就把它的值改称 true ，打开 主题配置文件 ，修改如下配置 1234567891011# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 3.20 在文章底部增加版权信息在目录 next/layout/_macro/ 下添加 my-copyright.swig : 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=\"my_post_copyright\"&gt; &lt;script src=\"//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js\"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/sweetalert/dist/sweetalert.min.js\"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=\"&#123;&#123; url_for(page.path) &#125;&#125;\"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=\"/\" title=\"访问 &#123;&#123; theme.author &#125;&#125; 的个人博客\"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(\"YYYY年MM月DD日 - HH:mm\") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(\"YYYY年MM月DD日 - HH:mm\") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=\"&#123;&#123; url_for(page.path) &#125;&#125;\" title=\"&#123;&#123; page.title &#125;&#125;\"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=\"copy-path\" title=\"点击复制文章链接\"&gt;&lt;i class=\"fa fa-clipboard\" data-clipboard-text=\"&#123;&#123; page.permalink &#125;&#125;\" aria-label=\"复制成功！\"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=\"fa fa-creative-commons\"&gt;&lt;/i&gt; &lt;a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/\" target=\"_blank\" title=\"Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)\"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(\".fa-clipboard\").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: \"\", text: '复制成功', icon: \"success\", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录 next/source/css/_common/components/post/ 下添加 my-post-copyright.styl ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改 next/layout/_macro/post.swig : 12345678910111213&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;# ---------在下面的代码之前，添加上面部分的代码----------&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt;# ------------------------------------------------------ 修改 next/source/css/_common/components/post/post.styl 文件，在最后一行增加代码： 1@import \"my-post-copyright\" 写博客的时候，需要添加 copyright 做限制。 12345678910111213---title: hexo站点配置+next主题配置tags: - 博客 - hexo - next - 主题categories: - 博客comments: truecopyright: truedate: 2019-01-10 15:31:50--- 3.21 DaoVoice在线联系在 Daovoice官网 注册账户，注册需要邀请码 b3c7d22e ，注册完成之后会获得一个 appid ，位置在 然后打开 themes/next/layout/_partials/head.swig 文件，在文件中加入以下代码，位置没有要求。 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[\"DaoVoiceObject\"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=\"utf-8\";m.parentNode.insertBefore(a,m)&#125;)(window,document,\"script\",('https:' == document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/faff8786.js\",\"daovoice\") daovoice('init', &#123; app_id: \"&#123;&#123;theme.daovoice_app_id&#125;&#125;\" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 下面是我的配置 打开 主题配置文件 添加以下代码（将 daovoice_app_id 替换成你自己的） 123# Online contact daovoice: truedaovoice_app_id: ffffffff 保存后部署，就可以看到效果了，在 Daovoice 上可以修改聊天窗口的颜色和位置，可以关联微信小程序，使用微信来接收消息。大家自己摸索。 3.22 点击出现小爱心效果3.23 添加站内搜索功能修改 主题配置文件 中的 local_search 字段，将 enable 的值改为 true 。这个是添加本地搜索的功能，网上还有 algolia_search 搜索，大家感兴趣的话可以自己学习，不过我感觉本地搜索够用了。 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 3.24 去掉文章目录标题的自动编号修改 主题配置文件 中的 toc 字段，将 number 的值改称 false。 1234toc: enable: true # Automatically add list number to toc. number: false 3.25 修改文章底部 # 号标签的图标去掉文章后面的标签前面的#号。修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将#换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 3.26 文章末尾添加“本文结束”标记在路径 \\themes\\next\\layout\\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #636363;font-size:14px;letter-spacing: 10px&quot;&gt;本文结束&lt;i class=&quot;fa fa-bell&quot;&gt;&lt;/i&gt;感谢您的阅读&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开 \\themes\\next\\layout\\_macro\\post.swig 文件，搜索 END POST BODY ，在 这之后， 添加以下代码： 12345&lt;div&gt;&#123;% if not is_index %&#125;&#123;% include &apos;passage-end-tag.swig&apos; %&#125;&#123;% endif %&#125;&lt;/div&gt; 打开 主题配置文件 ，在末尾添加 12passage_end_tag: enabled: true 3.27 修改代码块自定义样式打开 \\themes\\next\\source\\css\\_custom\\custom.styl 文件，加入 1234567891011121314code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; color 可以更改成自己喜欢的颜色。","categories":[{"name":"博客","slug":"博客","permalink":"https://melville.club/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://melville.club/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://melville.club/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://melville.club/tags/next/"},{"name":"主题","slug":"主题","permalink":"https://melville.club/tags/主题/"}]},{"title":"使用workbench编译报错“变量重复定义”","slug":"使用workbench编译报错“变量重复定义”","date":"2019-01-11T09:34:53.000Z","updated":"2019-01-16T06:32:08.549Z","comments":true,"path":"/posts/a-2019-01-11-17-34-53.html","link":"","permalink":"https://melville.club/posts/a-2019-01-11-17-34-53.html","excerpt":"今天在其他同事编写的demo的基础上做修改，使用workbench编译时报了 main.c 中变量重复定义的错误，查遍整个工程，只有一个 config.c 文件定义了该变量，并没有重复定义的情况。 刚开始怀疑过编译器是不是坏了，我把工程全部删掉重新做一遍，还是一样的错误。排查了很久，最后发现在 main.c 文件的中间，包含了定义该变量的 config.c 文件（#include &quot;config.c&quot;），所以变量被重复定义了。 真让人苦恼，搞不懂为什么我的同事要这样做。","text":"今天在其他同事编写的demo的基础上做修改，使用workbench编译时报了 main.c 中变量重复定义的错误，查遍整个工程，只有一个 config.c 文件定义了该变量，并没有重复定义的情况。 刚开始怀疑过编译器是不是坏了，我把工程全部删掉重新做一遍，还是一样的错误。排查了很久，最后发现在 main.c 文件的中间，包含了定义该变量的 config.c 文件（#include &quot;config.c&quot;），所以变量被重复定义了。 真让人苦恼，搞不懂为什么我的同事要这样做。","categories":[{"name":"bug","slug":"bug","permalink":"https://melville.club/categories/bug/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://melville.club/tags/bug/"},{"name":"workbench","slug":"workbench","permalink":"https://melville.club/tags/workbench/"},{"name":"调试","slug":"调试","permalink":"https://melville.club/tags/调试/"}]},{"title":"hexo 搭建博客添加自定义域名","slug":"hexo-搭建博客添加自定义域名","date":"2019-01-10T07:32:40.000Z","updated":"2019-01-16T06:31:23.995Z","comments":true,"path":"/posts/a-2019-01-10-15-32-40.html","link":"","permalink":"https://melville.club/posts/a-2019-01-10-15-32-40.html","excerpt":"","text":"https://blog.github.com/2018-05-01-github-pages-custom-domains-https/https://help.github.com/articles/setting-up-an-apex-domain/#configuring-a-records-with-your-dns-providerhttps://jp.v2ex.com/t/451406","categories":[{"name":"博客","slug":"博客","permalink":"https://melville.club/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://melville.club/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://melville.club/tags/hexo/"},{"name":"自定义域名","slug":"自定义域名","permalink":"https://melville.club/tags/自定义域名/"}]},{"title":"hexo站点配置+next主题配置（一）","slug":"hexo站点配置+next主题配置-之一","date":"2019-01-10T07:31:50.000Z","updated":"2019-01-16T06:31:29.307Z","comments":true,"path":"/posts/a-2019-01-10-15-31-50.html","link":"","permalink":"https://melville.club/posts/a-2019-01-10-15-31-50.html","excerpt":"写在前面大家一定要区分站点配置文件和主题配置文件所在位置，因为两个文件的文件名相同，都是 _config.yml ，刚开始接触时容易混淆。如果大家按照步骤做完之后，没能达到效果，请优先检查所配置项的格式，比如 是否在需要加空格的地方忘记加空格。 站点配置文件： 位置在主目录下（主目录就是你博客初始化的目录）主题配置文件： 位置在themes文件夹下面的相应主题根目录（比如next主题的配置文件在 /themes/next 下面）","text":"写在前面大家一定要区分站点配置文件和主题配置文件所在位置，因为两个文件的文件名相同，都是 _config.yml ，刚开始接触时容易混淆。如果大家按照步骤做完之后，没能达到效果，请优先检查所配置项的格式，比如 是否在需要加空格的地方忘记加空格。 站点配置文件： 位置在主目录下（主目录就是你博客初始化的目录）主题配置文件： 位置在themes文件夹下面的相应主题根目录（比如next主题的配置文件在 /themes/next 下面） 1. 下载主题 hexo主题下载 ，里面有很多hexo的主题，选择一款喜欢的主题，点进去，会跳转到该主题的GitHub页面，download到本地。并将主题 文件夹 放到themes文件夹下面。然后在站点配置文件中更改为该主题，就可以使用了，下面会介绍如何更改。 2. 站点配置2.1 站点文件的基本配置参数网站 参数 描述 默认值 title 网站标题 subtitle 网站副标题 description 网站描述 keywords 网站关键词 author 你的名字 language 网站使用的语言 timezone 网站时区 Hexo 默认使用您电脑的时区 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 注意： 如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址： 默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为 example.com，您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html， 它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 HH:mm:ss Hexo 使用 Moment.js 来解析和显示时间。 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 备注 Plugins 插件 Themes 当前主题名称 值为false时禁用主题 部署 参数 描述 type 部署类型 repo 仓库地址 branch 仓库分支 2.2 参数配置我只介绍平时比较关注的配置，其它配置项大家自己摸索。 2.2.1 配置网站以下是我的网站配置 1234567title: Melville&apos;s blogsubtitle: 个人博客description: 改革春风吹满地keywords:author: Melvillelanguage: zh-Hans # 网站语言设置为中文timezone: 2.2.2 配置网址以下是我的网址配置，URL 配置成自己的网址，https:melville.club 是我的自定义域名，如果没有自定义域名，配置成GitHub Pages分配的网址即可。 1234url: https:melville.clubroot: /permalink: :title.htmlpermalink_defaults: 2.2.3 配置主题默认主题是 landscape，替换成自己下载的主题的 文件夹的名字 （如果主题文件夹的名字不是主题的名字，建议改成一致），我的是next主题（刚下载下来时，主题文件夹的名字是 hexo-theme-next-master ，我将其改成了 next），所以我的 themes 文件夹下面有 /themes/landscape 和 /themes/next 两个主题。使用一个主题，将其它主题注掉即可。 12## theme: landscapetheme: next 2.2.4 配置部署参数以下是我的部署参数配置，repo 在GitHub新建的GitHub Pages仓库中获取。 1234deploy: type: git repo: git@github.com:do-do-do/do-do-do.github.io.git branch: master 3. 主题配置接下来就可以进行主题的配置了，本文以next主题为例子，其它主题配置方法类似。 3.1 选择主题风格 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持四种 Scheme，他们是： Muse： 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist： Muse 的紧凑版本，整洁有序的单栏外观 Pisces： 双栏 Scheme，小家碧玉似的清新 Gemini： 双兰Scheme，简洁美观Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。你会看到有四行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 1234#scheme: Muse #scheme: Mist #scheme: Piscesscheme: Gemini 3.2 设置语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： 1language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 语言 代码 设定示例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt or language: pt-BR 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id Korean ko language: ko 3.3 设置菜单设置菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件，修改以下内容： a. 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是： 名称: 归档位置 || 图标。其中名称并不直接显示在页面上，它将用于匹配图标以及翻译。默认是没有那么多菜单项的，下面会教大家怎么创建菜单项。 123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 若你的站点运行在子目录中，请将链接前缀的 / 去掉 b. 添加标签、分类等页面 刚开始是没有那么多菜单项的，我们需要自己手动创建，比如添加 分类（categories） 页面，输入下面的指令 1hexo new page categories 这时候会在hexo中的source目录下面生成一个 categories 文件夹，这是文件夹就是博客文章 分类页面 的归档。创建完成之后，我们需要在 主题配置文件 中，将 menu 中的 categories 前面的 # 去掉。重新 hexo g -d 部署后，就可以看到页面多了一个分类项。大家可以根据需要创建其它的菜单项，比如 tags（标签）、about（关于） 等等。 创建了这些菜单项有什么用呢？各个菜单项的用法各不相同，我只介绍三个常用的菜单项，tags、archives、categories。这三个项是比较特殊的，他们的页面在 /themes/layout/ 下面已经给出来了，就是相应的 .swig 文件。我们一般不用动它，只要知道如何使用就行了。 我们新建一片博客，只需要在博客开头给文章做好分类和标签即可，archives 不用关心，hexo自己会将你的博客归档。如下： 123456789title: hexo站点配置+next主题配置tags: - 博客 - hexo - next - 主题categories: - 博客date: 2019-01-10 15:31:50 c. 设置菜单项的显示文本。在第一步和第二步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 search。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： 1234567menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 d. 设定菜单项图标。大家可以从 Font Awesome 上查找喜欢的图标，并拷贝其图标名称，替换掉 menu 项中 || 后面的图标名称即可。 3.4 设置侧边栏位置及显示默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： left - 靠左放置 right - 靠右放置 12sidebar: position: left 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 12sidebar: display: post 3.5 添加侧边栏社交链接给侧边栏添加社交链接，可以通过修改 主题配置文件 中的 social 字段来添加。 123456789101112#social: #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype next主题默认是不打开 social 的，我们把 social 前面的 # 删掉，添加自己的社交链接即可，格式为 “名称: 社交网址 || 图标”, 注意空格 。 3.6 关闭网站动画效果每次打开网页的时候，是不是感觉加载很慢？这是因为next主题的一些动画效果导致的，我们可以通过修改 主题配置文件 中的 motion 字段来关闭它。 12motion: enable: false 部署后再打开网页试试，是不是快到飞起。 3.7 设置网站图标自己的博客当然要用自己的网站图标，在没设置自己的网站图标时，浏览器的标签上显示的是next主题的图标 N ，下面是我自己设置的图标。 我们可以修改 主题配置文件 中的 favicon 字段来设置网站图标，首先我们需要先制作自己的图标，可以通过 比特虫 来制作图标，需要制作 16x16 和 32x32 两个大小的图标，分别重命名为 favicon-16x16-next.ico 和 favicon-32x32-next.ico,然后将两个图标文件放在 /source/images 目录下，并修改配置。 123favicon: small: /images/favicon-16x16-next.ico medium: /images/favicon-32x32-next.ico 3.8 设置头像选好自己喜欢的头像，将其命名为 avatar.png 也可以是 .gif 文件，并放在 source/images 目录下，修改 主题配置文件 的 avatar 字段。 123456# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.png 比较老的next版本，是直接修改 avatar 字段 1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.png 3.9 网页底部显示建站时间和图标修改修改 主题配置文件 中的 footer 字段，将 since 修改成建站时间，icon 修改图标，可以从 Font Awesome 中查找自己喜欢的图标。 1234567footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2018 # Icon between year and copyright info. icon: snowflake-o # snowflake-o是雪花的图标，默认是 user 3.10 去掉网站底部显示的 “由hexo强力驱动” 字样修改 主题配置文件 中的 footer 字段，将 powered 设置为 false。 3.11 增加评论功能next主题支持多种评论系统，像是多说、网易云跟帖、畅言、Gitment、Disqus、Hypercomments、valine，多说和网易云跟帖已经挂了，Gitment的服务器也不行了，Disqus、Hypercomments是国外的，速度慢，目前只有 valine 好用一些。首先进入 leancloud官网 注册一个valine账号。 注册完之后需要创建应用，应用名字没有特别要求，然后进入应用，找到 设置-&gt;应用Key ，会看到有 App ID 和 App Key 。 进入 主题配置文件 ，找到 valine 字段，将你的 App ID 和 App Key 分别填到 appid 和 appkey 的位置上，将 enable 改成 true。 12345678910valine: enable: true appid: ???? # your leancloud application appid appkey: ???? # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 老铁，说点啥... # comment box placeholder avatar: mp # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 然后进入 设置-&gt;安全中心 ，服务开关只保留 数据存储 即可，Web安全域名中添加上自己的博客域名。 修改完后，部署到网站上，此时文章底部应该出现了评论框。 3.12 禁用指定文章的评论功能valine 评论系统默认所有页面都可以评论，包括关于页面、标签页面，很明显，我们并不是所有页面都需要评论功能。怎么关闭这些页面的评论功能呢？很简单，在文章开头加上 comments 限定就行。&quot;comments: false&quot; 关闭评论， &quot;comments: true&quot; 打开评论，比如禁止博客文章的评论： 12345678910title: hexo站点配置+next主题配置tags: - 博客 - hexo - next - 主题categories: - 博客comments: falsedate: 2019-01-10 15:31:50 像是关于页面、标签页面，他们的文件是在 source 目录相应文件夹下的 index.md 文件。加上 &quot;comments: false&quot; 就可以了。 3.13 增加阅读统计在 3.11 章节中我们创建了leancloud账户，阅读统计的功能使用leancloud就可以实现，登录leancloud，进入 应用-&gt;存储-&gt;创建Class ， 创建Class时，名称一定要是 Counter ，这是为了适配 next 主题，由于LeanCloud升级了默认的ACL权限，如果你想避免后续因为权限的问题导致次数统计显示不正常，建议在此处选择 无限制。 创建完成之后，左侧数据栏应该会多出一栏名为 Counter 的栏目，前面带下划线的栏目都是系统预定好的表。在 主题配置文件 中搜索 leancloud_visitors 修改配置，将你的 appid 和 appkey 填入相应位置。 1234leancloud_visitors: enable: true app_id: app_key: 3.14 开启微信支付宝打赏功能越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。只需要 主题配置文件 中填入微信和支付宝收款二维码图片地址，即可开启该功能。将微信和支付宝的收款二维码放在 /themes/next/images 目录下，并分别重命名为 “wechatpay.jpg” 和 “alipay.jpg” ，修改配置： 1234reward: enable: true wechatpay: /images/wechatpay.jpg alipay: /images/alipay.jpg 3.15 修改打赏部分字体动画Next打赏部分的动画是鬼畜一般的不停地抖动，看着很难受，所以博主把它改为只循环三遍，打开文件 themes/next/source/css/_common/components/post/post-reward.styl ，把微信和支付宝的动画代码注释即可，如下： 12345678910111213/* 关闭文字闪动#wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;#alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/&#125; 3.16 增加公益404页面新建 公益404页面 1hexo new page 404 修改 &quot;/source/404/index.md&quot; ，添加以下代码： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在 主题配置文件 中，修改 menu ，添加404，如下： 1234567menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive about: /about/ || user commonweal: /404/ || heartbeat hexo站点配置+next主题配置（二）","categories":[{"name":"博客","slug":"博客","permalink":"https://melville.club/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://melville.club/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://melville.club/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://melville.club/tags/next/"},{"name":"主题","slug":"主题","permalink":"https://melville.club/tags/主题/"}]},{"title":"史上最全hexo+GitHubPages搭建个人博客","slug":"史上最全hexo-GitHub-Pages搭建个人博客","date":"2019-01-09T06:12:57.000Z","updated":"2019-01-16T06:32:13.546Z","comments":true,"path":"/posts/a-2019-01-09-14-12-57.html","link":"","permalink":"https://melville.club/posts/a-2019-01-09-14-12-57.html","excerpt":"前言反反复复搞了很多天，终于搭建好自己的博客了，因为要配置的个性化东西很多，而且网上查找的结果都是比较零散的，所以我搭建博客时浪费了很多时间，也走了很多的坑。为了节约大家的时间，方便大家搭建自己的博客，特地记录下搭建的过程。如果大家在搭建过程中有什么疑问，欢迎留言，同时也请大家收藏网站，防止自己忘记!!! 1. GitHub Pages和hexo简介 GitHub Pages旨在从GitHub存储库托管您的个人，组织或项目页面，是为您和您的项目快速发布漂亮网站的最佳方式。使用GitHub Pages搭建个人网站，可以省去购买服务器、域名等一系列费用，搭建起来非常简单。而且可以上传网页的源代码、更改网页的样式，全部在自己的掌控之中。","text":"前言反反复复搞了很多天，终于搭建好自己的博客了，因为要配置的个性化东西很多，而且网上查找的结果都是比较零散的，所以我搭建博客时浪费了很多时间，也走了很多的坑。为了节约大家的时间，方便大家搭建自己的博客，特地记录下搭建的过程。如果大家在搭建过程中有什么疑问，欢迎留言，同时也请大家收藏网站，防止自己忘记!!! 1. GitHub Pages和hexo简介 GitHub Pages旨在从GitHub存储库托管您的个人，组织或项目页面，是为您和您的项目快速发布漂亮网站的最佳方式。使用GitHub Pages搭建个人网站，可以省去购买服务器、域名等一系列费用，搭建起来非常简单。而且可以上传网页的源代码、更改网页的样式，全部在自己的掌控之中。 Hexo 是一款基于Node.js的快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。依赖少易于安装使用，是搭建博客的首选框架。 2. 创建GitHub Pages2.1 注册GitHub如果你看到这篇文章，90%的可能性已经是GitHub会员了，这里就不介绍注册步骤了，GitHub入口。 2.2 创建仓库进入GitHub个人页面，点击右上角的 + 号新建仓库。 在新建仓库页面，输入仓库名字，选择pulic和初始化README，点击 Create repository 新建仓库，如下图所示。 注意：仓库名字一定要和自己的用户名一样，规则就是 用户名.github.io。不这样命名会出错。 创建完成后，在个人仓库页面会出现刚才创建的仓库，点击仓库名称进入仓库。 进入仓库后，点击Settings，往下翻，查看仓库的GitHub Pages，已经分配了一个网址，这个网址就是你的博客地址，可以访问。 3. 安装工具并设置3.1 安装Git，关联自己的远程仓库Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。Git是一个工具，GitHub是用于托管项目的网站，不要搞混淆了。 Git下载地址下载并安装完成后，鼠标右键点击桌面（或文件系统的其它地方），会出现 Git GUI Here, Git Bash Here 两个选项。 点击 Git Bash Here，打开命令窗口。输入以下指令设置Git用户信息。 12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件 1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 输入这个命令时会提示一些信息，直接三次回车即可，然后在 C:\\Users\\用户名\\.ssh 目录下会生成两个文件 id_rsa 和 id_rsa.pub。 id_rsa是私钥文件，id_rsa.pub是公钥文件。将 id_rsa.pub用记事本打开，拷贝文件里面的所有内容。 然后打开GitHub个人主页，点击右上角的头像，选择Settings 找到 SSH and GPG keys，点击 New SSH key。 输入标题和key的内容，点击 Add SSH key 在Git Bash中检测GitHub公钥设置是否成功，输入 1ssh git@github.com 结果如下图所示，则说明设置成功 GitHub添加SSH key的目的：通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了SSH，当你推送的时候，Git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。 3.2 clone远程仓库到本地不克隆仓库也可以正常部署博客，这一步的目的是为了方便提交本地的配置文件到GitHub上，在 5.2 章节会提到。在本地新建一个空文件夹，克隆刚才新建的仓库 1git clone 仓库的URL 其中，仓库的URL可从仓库主页获取，如下图： 3.3 安装node.jsNode.js下载，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js和npm是否安装成功，在命令行中输入 12node -v #显示版本号则说明安装成功npm -v #显示版本号则说明安装成功 3.4 安装hexo进入我们在 3.2 章节中创建的文件夹中，按住shift键，右击鼠标点击命令行（或者是powershell，都是一样的）。输入 1npm install -g hexo-cli 开始安装hexo，注意，安装hexo以及下面对hexo初始化的操作，一定要在刚才创建的文件夹中进行。 4. 初始化博客以及常用命令hexo安装完成后，开始对其进行初始化 1hexo init 初始化的过程稍微有点长，需要等待一会儿。初始化完成之后，文件夹下面应该有这些文件 node_modules： 框架，一般不用改动 scaffolds： scaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容 source： source是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。 themes： 放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。 config.yml： 博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。 package.json： 应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。 测试一下，依次输入 12hexo ghexo s 打开浏览器，输入 localhost:4000，回车，出现 OK，博客搭建已经完成一半了，接下来我先介绍几个常用的命令 命令 简写 描述 备注 hexo init [folder] - 在指定目录初始化博客 如果不加[folder]参数，则默认在当前目录初始化 hexo clean - 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo generate hexo g 生成静态文件 - hexo deploy hexo d 部署网站 可以和hexo g合并成 hexo g -d，生成静态网页并部署网站，用的比较多 hexo version hexo -v 查看hexo版本 - hexo new [layout] [filename] - 新建一篇文章 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 hexo publish [layout] [filename] - 发表草稿 - hexo server hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/ 加参数-p，可以指定端口号 hexo list [type] - 列出网站指定类型的资料 type类型可以是 page, post, route, tag, category等 5. GitHub Pages和hexo关联5.1 更改hexo站点配置文件打开文件夹下面的_config.yml文件 翻到最后，填写配置 注意:号后面有一个空格。如下图所示 其中,repo可以在你新建的仓库中获取到 5.2 给仓库创建分支这里的branch填的是master，这个master是你建立的github.io仓库的主干，用于存放生成的静态网页，你从自己博客网站上看到的东西都是在master这个主干上，而我们本地存放的不仅有博客文章，还有网站的配置文件，这就引发了一个问题，如果我们的电脑硬盘坏了，这些配置文件就丢了，我们再想更改网站的配置，就只能从头再来。所以我们要及时对这些文件做好备份，最好的方法当然是备份到GitHub上，我们可以在master的基础上创建一个分支，比如叫hexo，把网站的配置文件都放在hexo分支上，如果我们电脑硬盘坏了或者想换电脑了，直接从hexo分支上pull到本地即可。下面是创建的方法： 直接在此处输入hexo，如果没有这个分支，会提示创建，直接回车即可创建hexo分支。如下图所示 点击 branches，将GitHub的默认分支改成hexo 创建好以后，就可以将我们本地的文件提交到hexo上了。关于git的命令，大家自己百度学习。 123git add . # 添加所有文件git commit -m &quot;描述&quot; # 提交git push origin hexo # push到hexo分支上 6. 新建一篇博客，并部署首先安装Git部署插件 1npm install hexo-deployer-git --save 接下来就可以写博客啦，我们先新建一个文章，部署上去看看效果。 12hexo new myTestFilehexo g -d 部署完成后，打开你的博客网址：https://用户名.github.io，在主页上就能看到你刚才的文章啦。 7. 添加个性主题及配置由于文章内容较多，主题配置放在了另两篇文章， hexo站点配置+next主题配置（一） hexo站点配置+next主题配置（二） 9. 自定义域名由于文章内容较多，自定义域名放在了另一篇文章， hexo的自定义域名","categories":[{"name":"博客","slug":"博客","permalink":"https://melville.club/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://melville.club/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://melville.club/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://melville.club/tags/next/"}]},{"title":"Windows10企业版激活方法","slug":"Windows10企业版激活方法","date":"2019-01-07T09:52:13.000Z","updated":"2019-01-16T06:32:00.518Z","comments":true,"path":"/posts/a-2019-01-07-17-52-13.html","link":"","permalink":"https://melville.club/posts/a-2019-01-07-17-52-13.html","excerpt":"1. 效果图 2. 激活方法以管理员身份运行命令提示符，依次输入以下命令：","text":"1. 效果图 2. 激活方法以管理员身份运行命令提示符，依次输入以下命令： a. 卸载产品秘钥1slmgr.vbs /upk b. 安装产品秘钥1slmgr /ipk NPPR9-FWDCX-D2C8J-H872K-2YT43 c. 设置计算机名称1slmgr /skms zh.us.to d. 激活1slmgr /ato 3. 查看上述步骤完成后，如果提示成功激活，应该可以从控制面板-&gt;系统和安全-&gt;系统中看到激活状态，如果还是未激活，关机重启后再查看。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://melville.club/categories/Windows/"}],"tags":[{"name":"激活","slug":"激活","permalink":"https://melville.club/tags/激活/"},{"name":"Windows10","slug":"Windows10","permalink":"https://melville.club/tags/Windows10/"}]},{"title":"SublimeText3激活码","slug":"SublimeText3激活码","date":"2019-01-07T09:46:40.000Z","updated":"2019-01-16T06:31:52.315Z","comments":true,"path":"/posts/a-2019-01-07-17-46-40.html","link":"","permalink":"https://melville.club/posts/a-2019-01-07-17-46-40.html","excerpt":"1. SublimeText3激活码version 3.1.1，build 3176 12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------","text":"1. SublimeText3激活码version 3.1.1，build 3176 12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------","categories":[{"name":"工具","slug":"工具","permalink":"https://melville.club/categories/工具/"}],"tags":[{"name":"激活","slug":"激活","permalink":"https://melville.club/tags/激活/"},{"name":"SublimeText3","slug":"SublimeText3","permalink":"https://melville.club/tags/SublimeText3/"}]},{"title":"VMwareWorkstation15Pro激活秘钥","slug":"VMwareWorkstation15Pro激活秘钥","date":"2019-01-07T09:20:09.000Z","updated":"2019-01-16T06:31:56.653Z","comments":true,"path":"/posts/a-2019-01-07-17-20-09.html","link":"","permalink":"https://melville.club/posts/a-2019-01-07-17-20-09.html","excerpt":"1. 激活秘钥123456YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8UG5J2-0ME12-M89WY-NPWXX-WQH88UA5DR-2ZD4H-089FY-6YQ5T-YPRX6GA590-86Y05-4806Y-X4PEE-ZV8E0ZF582-0NW5N-H8D2P-0XZEE-Z22VAYA18K-0WY8P-H85DY-L4NZG-X7RAD","text":"1. 激活秘钥123456YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8UG5J2-0ME12-M89WY-NPWXX-WQH88UA5DR-2ZD4H-089FY-6YQ5T-YPRX6GA590-86Y05-4806Y-X4PEE-ZV8E0ZF582-0NW5N-H8D2P-0XZEE-Z22VAYA18K-0WY8P-H85DY-L4NZG-X7RAD 2. 永不过期","categories":[{"name":"工具","slug":"工具","permalink":"https://melville.club/categories/工具/"}],"tags":[{"name":"激活","slug":"激活","permalink":"https://melville.club/tags/激活/"},{"name":"VMwareWorkstation","slug":"VMwareWorkstation","permalink":"https://melville.club/tags/VMwareWorkstation/"},{"name":"秘钥","slug":"秘钥","permalink":"https://melville.club/tags/秘钥/"}]},{"title":"iptables和firewalled的区别","slug":"iptables和firewalled的区别","date":"2018-10-23T02:15:57.000Z","updated":"2019-01-16T06:31:33.666Z","comments":true,"path":"/posts/a-2018-10-23-10-15-57.html","link":"","permalink":"https://melville.club/posts/a-2018-10-23-10-15-57.html","excerpt":"简述保证数据的安全性是继可用性之后最为重要的一项工作，防火墙技术作为公网与内网之间的保护屏障，起着至关重要的作用。面对同学们普遍不了解在红帽RHEL7系统中新旧两款防火墙的差异，刘遄老师决定先带领读者正确的认识在红帽RHEL7系统中firewalld防火墙服务与iptables防火墙服务之间的关系，从理论和事实层面剖析真相。本章节内将会分别使用iptables、firewall-cmd、firewall-config和Tcp_wrappers等防火墙策略配置服务来完成数十个根据真实工作需求而设计的防火墙策略配置实验，让同学们不仅能够熟练的对请求数据包流量进行过滤，还能够基于服务程序进行允许和关闭操作，做到保证Linux系统安全万无一失。","text":"简述保证数据的安全性是继可用性之后最为重要的一项工作，防火墙技术作为公网与内网之间的保护屏障，起着至关重要的作用。面对同学们普遍不了解在红帽RHEL7系统中新旧两款防火墙的差异，刘遄老师决定先带领读者正确的认识在红帽RHEL7系统中firewalld防火墙服务与iptables防火墙服务之间的关系，从理论和事实层面剖析真相。本章节内将会分别使用iptables、firewall-cmd、firewall-config和Tcp_wrappers等防火墙策略配置服务来完成数十个根据真实工作需求而设计的防火墙策略配置实验，让同学们不仅能够熟练的对请求数据包流量进行过滤，还能够基于服务程序进行允许和关闭操作，做到保证Linux系统安全万无一失。 1. 防火墙管理工具保证数据的安全性是继可用性之后最为重要的一项工作，众所周知外部公网相比企业内网更加的“罪恶丛生”，因此防火墙技术作为公网与内网之间的保护屏障，虽然有软件或硬件之分，但主要功能都是依据策略对外部请求进行过滤。防火墙技术能够做到监控每一个数据包并判断是否有相应的匹配策略规则，直到匹配到其中一条策略规则或执行默认策略为止，防火墙策略可以基于来源地址、请求动作或协议等信息来定制，最终仅让合法的用户请求流入到内网中，其余的均被丢弃。 在红帽RHEL7系统中Firewalld服务取代了Iptables服务，对于接触Linux系统比较早或学习过红帽RHEL6系统的读者来讲，突然改用Firewalld服务后确实不免会有些抵触心理，或许会觉得Firewalld服务是一次不小的改变。但其实Iptables服务与Firewalld服务都不是真正的防火墙，它们都只是用来定义防火墙策略功能的“防火墙管理工具”而已，iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实同时有多个防火墙管理工具共同存在，它们的作用都是为了方便运维人员管理Linux系统的防火墙策略，而咱们只要配置妥当其中一个就足够了。虽然各个工具之间各有优劣特色，但对于防火墙策略的配置思路上是保持一致的，同学们甚至可以不用完全掌握本章节内的知识，而是在这诸多个防火墙管理工具中任选一款来学透即可，完全能够满足日常的工作所需。 2. iptables在较早期的Linux系统中想配置防火墙默认使用的都是iptables防火墙管理命令，而新型Firewalld防火墙管理服务已经被投入使用多年，但还记得刘遄老师在第0章0.6小节里谈到过企业不愿意及时升级的原因吧，于是不论出于什么样的原因，目前市场上还有大量的生产环境中在使用着iptables命令来管理着防火墙的规则策略。虽然明知iptables可能有着即将被“淘汰”的命运，但为了让同学们不必在面试时尴尬以及看完手中这本《Linux就该这么学》书籍后能“通吃”各个版本的Linux系统，刘遄老师觉得还是有必要把这一项技术好好卖力气讲一下，更何况各个工具的配置防火墙策略思路上大体一致，具有很高的相同性及借鉴意义。 2.1 策略与规则链防火墙会从上至下来读取规则策略，一旦匹配到了合适的就会去执行并立即结束匹配工作，但也有转了一圈之后发现没有匹配到合适规则的时候，那么就会去执行默认的策略。因此对防火墙策略的设置无非有两种，一种是“通”，一种是“堵”——当防火墙的默认策略是拒绝的，就要设置允许规则，否则谁都进不来了，而如果防火墙的默认策略是允许的，就要设置拒绝规则，否则谁都能进来了，起不到防范的作用。 iptables命令把对数据进行过滤或处理数据包的策略叫做规则，把多条规则又存放到一个规则链中，规则链是依据处理数据包位置的不同而进行的分类，包括有：在进行路由选择前处理数据包（PREROUTING）、处理流入的数据包（INPUT）、处理流出的数据包（OUTPUT）、处理转发的数据包（FORWARD）、在进行路由选择后处理数据包（POSTROUTING）。从内网向外网发送的数据一般都是可控且良性的，因此显而易见咱们使用最多的就是INPUT数据链，这个链中定义的规则起到了保证私网设施不受外网骇客侵犯的作用。 比如您所居住的社区物业保安有两条规定——“禁止小商贩进入社区，各种车辆都需要登记”，这两条安保规定很明显应该是作用到了社区的正门（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序规则，咱们可以猜想有多种情况——比如来访人员是小商贩，则会被物业保安直接拒绝在大门外，也无需再对车辆进行登记，而如果来访人员是一辆汽车，那么因为第一条禁止小商贩策略就没有被匹配到，因而按顺序匹配到第二条策略，需要对车辆进行登记，再有如果来访的是社区居民，则既不满足小商贩策略，也不满足车辆登记策略，因此会执行默认的放行策略。 不过只有规则策略还不能保证社区的安全，物业保安还应该知道该怎么样处理这些被匹配到的流量，比如包括有“允许”、“登记”、“拒绝”、“不理他”，这些动作对应到iptables命令术语中是ACCEPT（允许流量通过）、LOG（记录日志信息）、REJECT（拒绝流量通过）、DROP（拒绝流量通过）。允许动作和记录日志工作都比较好理解，着重需要讲解的是这两条拒绝动作的不同点，其中REJECT和DROP的动作操作都是把数据包拒绝，DROP是直接把数据包抛弃不响应，而REJECT会拒绝后再回复一条“您的信息我已收到，但被扔掉了”，让对方清晰的看到数据被拒绝的响应。就好比说您有一天正在家里看电视，突然有人敲门，透过“猫眼”一看是推销商品的，咱们如果不需要的情况下就会直接拒绝他们（REJECT）。但如果透过“猫眼”看到的是债主带了几十个小弟来讨债，这种情况不光要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP），这就是两种拒绝动作的不同之处。 把Linux系统设置成REJECT拒绝动作策略后，对方会看到本机的端口不可达的响应： 12345678[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.From 192.168.10.10 icmp_seq=1 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=2 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=3 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=4 Destination Port Unreachable--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3002ms 把Linux系统设置成DROP拒绝动作策略后，对方会看到本机响应超时的提醒，无法判断流量是被拒绝，还是对方主机当前不在线： 12345[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, 100% packet loss, time 3000ms 2.2 基本的命令参数iptables是一款基于命令行的防火墙策略管理工具，由于该命令是基于终端执行且存在有大量参数的，学习起来难度还是较大的，好在对于日常控制防火墙策略来讲，您无需深入的了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，以便于能够更顺畅的胜任工作所需。iptables命令可以根据数据流量的源地址、目的地址、传输协议、服务类型等等信息项进行匹配，一旦数据包与策略匹配上后，iptables就会根据策略所预设的动作来处理这些数据包流量，另外再来提醒下同学们防火墙策略的匹配顺序规则是从上至下的，因此切记要把较为严格、优先级较高的策略放到靠前位置，否则有可能产生错误。下表中为读者们总结归纳了几乎所有常用的iptables命令参数，刘遄老师遵循《Linux就该这么学》书籍的编写初衷而设计了大量动手实验，让您无需生背硬记这些参数，可以结合下面的实例来逐个参阅即可。 参数 作用 -P 设置默认策略:iptables -P INPUT (DROP&#124;ACCEPT) -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D num 删除某一条规则 -s 匹配来源地址IP/MASK，加叹号”!”表示除这个IP外。 -d 匹配目标地址 -i 网卡名称 匹配从这块网卡流入的数据 -o 网卡名称 匹配从这块网卡流出的数据 -p 匹配协议,如tcp,udp,icmp –dport num 匹配目标端口号 –sport num 匹配来源端口号 -j 指定动作类型 使用iptables命令-L参数查看已有的防火墙策略： 1234567891011[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT all -- anywhere anywhere ctstate RELATED,ESTABLISHEDACCEPT all -- anywhere anywhere INPUT_direct all -- anywhere anywhere INPUT_ZONES_SOURCE all -- anywhere anywhere INPUT_ZONES all -- anywhere anywhere ACCEPT icmp -- anywhere anywhere REJECT all -- anywhere anywhere reject-with icmp-host-prohibited………………省略部分输出信息……………… 使用iptables命令-F参数清空已有的防火墙策略： 12345[root@linuxprobe ~]# iptables -F[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ………………省略部分输出信息……………… 把INPUT链的默认策略设置为拒绝： 如前面所提到的防火墙策略设置无非有两种方式，一种是“通”，一种是“堵”，当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉，同学们需要留意规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。 12345[root@linuxprobe ~]# iptables -P INPUT DROP[root@linuxprobe ~]# iptables -LChain INPUT (policy DROP)target prot opt source destination …………省略部分输出信息……………… 向INPUT链中添加允许icmp数据包流入的允许策略： 在日常运维工作中经常会使用到ping命令来检查对方主机是否在线，而向防火墙INPUT链中添加一条允许icmp协议数据包流入的策略就是默认允许了这种ping命令检测行为。 123456789101112131415[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, 100% packet loss, time 3000ms[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.156 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.117 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.099 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.090 ms--- 192.168.10.10 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 2999msrtt min/avg/max/mdev = 0.090/0.115/0.156/0.027 ms 删除INPUT链中的那条策略，并把默认策略还原为允许： 123456[root@linuxprobe ~]# iptables -D INPUT 1[root@linuxprobe ~]# iptables -P INPUT ACCEPT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination………………省略部分输出信息……………… 设置INPUT链只允许指定网段访问本机的22端口，拒绝其他所有主机的数据请求流量： 防火墙策略是按照从上至下顺序匹配的，因此请一定要记得把允许动作放到拒绝动作上面，否则所有的流量就先被拒绝掉了，任何人都获取不到咱们的业务。文中提到的22端口是下面第9章节讲的ssh服务做占用的资源，刘遄老师在这里挖个小坑~等读者们稍后学完再回来验证这个实验效果吧~ #屏蔽单个IP的命令是iptables -I INPUT -s 123.45.6.7 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令iptables -I INPUT -s 123.0.0.0/8 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令是iptables -I INPUT -s 123.45.6.0/24 -j DROP #指定几个ip123.45.6.0，123.45.6.1,能用ssh连接，其他均不行。iptables -I INPUT -s 123.45.6.0/123.45.6.2 -p tcp -j ACCEPT 1iptables -A INPUT -p tcp --dport 22 -j REJECT 12345678[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息……………… 使用IP地址在192.168.10.0/24网段内的主机访问服务器的22端口： 12345678[root@Client A ~]# ssh 192.168.10.10The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.root@192.168.10.10's password: Last login: Sun Feb 12 01:50:25 2017[root@Client A ~]# 使用IP地址在192.168.20.0/24网段外的主机访问服务器的22端口： 123[root@Client B ~]# ssh 192.168.10.10Connecting to 192.168.10.10:22...Could not connect to '192.168.10.10' (port 22): Connection failed. 向INPUT链中添加拒绝所有人访问本机12345端口的防火墙策略： 12345678910[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT[root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息……………… 向INPUT链中添加拒绝来自于指定192.168.10.5主机访问本机80端口（web服务）的防火墙策略： 12345678910[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息……………… 向INPUT链中添加拒绝所有主机不能访问本机1000至1024端口的防火墙策略： 12345678910111213[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable………………省略部分输出信息……………… 是不是还意犹未尽？但对于iptables防火墙管理命令的学习到此就可以结束了，考虑到以后防火墙的发展趋势，同学们只要能把上面的实例看懂看熟就可以完全搞定日常的iptables防火墙配置工作了。但请特别留意下，iptables命令配置的防火墙规则默认会在下一次重启时失效，所以如果您想让配置的防火墙策略永久的生效下去，还要执行一下保存命令： 12[root@linuxprobe ~]# service iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables: [ OK ] 3. firewalledRHEL7是一个集合多款防火墙管理工具并存的系统，Firewalld动态防火墙管理器服务（Dynamic Firewall Manager of Linux systems）是目前默认的防火墙管理工具，同时拥有命令行终端和图形化界面的配置工具，即使是对Linux命令并不熟悉的同学也能快速入门。相比于传统的防火墙管理工具还支持了动态更新技术并加入了“zone区域”的概念，简单来说就是为用户预先准备了几套防火墙策略集合（策略模板），然后可以根据生产场景的不同而选择合适的策略集合，实现了防火墙策略之间的快速切换。例如咱们有一台笔记本电脑每天都要在办公室、咖啡厅和家里使用，按常理推断最安全的应该是家里的内网，其次是公司办公室，最后是咖啡厅，如果需要在办公室内允许文件共享服务的请求流量、回到家中需要允许所有的服务，而在咖啡店则是除了上网外不允许任何其他请求，这样的需求应该是很常见的，在以前只能频繁的进行手动设置，而现在只需要预设好zone区域集合，然后轻轻点击一下就可以切换过去了上百条策略了，极大的提高了防火墙策略的应用效率，常见的zone区域名称及应用可见下表（默认为public）： 区域 默认规则策略 trusted 允许所有的数据包。 home 拒绝流入的数据包，除非与输出流量数据包相关或是ssh,mdns,ipp-client,samba-client与dhcpv6-client服务则允许。 internal 等同于home区域 work 拒绝流入的数据包，除非与输出流量数据包相关或是ssh,ipp-client与dhcpv6-client服务则允许。 public 拒绝流入的数据包，除非与输出流量数据包相关或是ssh,dhcpv6-client服务则允许。 external 拒绝流入的数据包，除非与输出流量数据包相关或是ssh服务则允许。 dmz 拒绝流入的数据包，除非与输出流量数据包相关或是ssh服务则允许。 block 拒绝流入的数据包，除非与输出流量数据包相关。 drop 拒绝流入的数据包，除非与输出流量数据包相关。 3.1 终端管理工具前面第2章学习Linux命令时刘遄老师提到过的，命令行终端是一种极富效率的工作方式，firewall-cmd命令是Firewalld动态防火墙管理器服务的命令行终端。它的参数一般都是以“长格式”来执行的，但同学们也不用太过于担心，因为红帽RHEL7系统非常酷的支持了部分命令的参数补齐，也正好包括了这条命令，也就是说现在除了能够用Tab键来补齐命令或文件名等等内容，还可以用Tab键来补齐下列长格式参数啦（这点特别的棒）。 参数 作用 –get-default-zone 查询默认的区域名称。 –set-default-zone=&lt;区域名称&gt; 设置默认的区域，永久生效。 –get-zones 显示可用的区域。 –get-services 显示预先定义的服务。 –get-active-zones 显示当前正在使用的区域与网卡名称。 –add-source= 将来源于此IP或子网的流量导向指定的区域。 –remove-source= 不再将此IP或子网的流量导向某个指定区域。 –add-interface=&lt;网卡名称&gt; 将来自于该网卡的所有流量都导向某个指定区域。 –change-interface=&lt;网卡名称&gt; 将某个网卡与区域做关联。 –list-all 显示当前区域的网卡配置参数，资源，端口以及服务等信息。 –list-all-zones 显示所有区域的网卡配置参数，资源，端口以及服务等信息。 –add-service=&lt;服务名&gt; 设置默认区域允许该服务的流量。 –add-port=&lt;端口号/协议&gt; 允许默认区域允许该端口的流量。 –remove-service=&lt;服务名&gt; 设置默认区域不再允许该服务的流量。 –remove-port=&lt;端口号/协议&gt; 允许默认区域不再允许该端口的流量。 –reload 让“永久生效”的配置规则立即生效，覆盖当前的。 –panic-on 开启应急状况模式。 –panic-off 关闭应急状况模式。 与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。 接下来的实验都很简单，但是提醒大家一定要仔细查看刘遄老师使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算是正确配置了防火墙策略，也可能无法达到预期的效果。 查看firewalld服务当前所使用的区域： 12[root@linuxprobe ~]# firewall-cmd --get-default-zonepublic 查询eno16777728网卡在firewalld服务中的区域： 12[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728public 把firewalld服务中eno16777728网卡的默认区域修改为external，并在系统重启后生效。分别查看当前与永久模式下的区域名称： 123456[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=eno16777728success[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728public[root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=eno16777728external 把firewalld服务的当前默认区域设置为public： 1234[root@linuxprobe ~]# firewall-cmd --set-default-zone=publicsuccess[root@linuxprobe ~]# firewall-cmd --get-default-zone public 启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）： 1234[root@linuxprobe ~]# firewall-cmd --panic-onsuccess[root@linuxprobe ~]# firewall-cmd --panic-offsuccess 查询public区域是否允许请求SSH和HTTPS协议的流量： 1234[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=sshyes[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=httpsno 把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效： 123456[root@linuxprobe ~]# firewall-cmd --zone=public --add-service=httpssuccess[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=httpssuccess[root@linuxprobe ~]# firewall-cmd --reloadsuccess 把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效： 1234[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http success[root@linuxprobe ~]# firewall-cmd --reload success 把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效： 1234[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcpsuccess[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports 8080-8081/tcp 把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效： 流量转发命令格式为firewall-cmd –permanent –zone=&lt;区域&gt; –add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标IP地址&gt; 1234[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10success[root@linuxprobe ~]# firewall-cmd --reloadsuccess 在客户端使用ssh命令尝试访问192.168.10.10主机的888端口： 1234567[root@client A ~]# ssh -p 888 192.168.10.10The authenticity of host '[192.168.10.10]:888 ([192.168.10.10]:888)' can't be established.ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '[192.168.10.10]:888' (ECDSA) to the list of known hosts.root@192.168.10.10's password:此处输入远程root管理员的密码Last login: Sun Jul 19 21:43:48 2017 from 192.168.10.10 firewalld中的富规则表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）： 1234[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.10.0/24\" service name=\"ssh\" reject\"success[root@linuxprobe ~]# firewall-cmd --reloadsuccess 在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）： 123[root@client A ~]# ssh 192.168.10.10Connecting to 192.168.10.10:22...Could not connect to '192.168.10.10' (port 22): Connection failed. 3.2 图形管理工具在各种版本的Linux系统中，几乎没有能让刘遄老师欣慰并推荐的图形化工具，但是firewall-config做到了。它是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张的说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 7中的防火墙策略。firewall-config的界面如图8-2所示，其功能具体如下。 1：选择运行时（Runtime）模式或永久（Permanent）模式的配置。2：可选的策略集合区域列表。3：常用的系统服务列表。4：当前正在使用的区域。5：管理当前被选中区域中的服务。6：管理当前被选中区域中的端口。7：开启或关闭SNAT（源地址转换协议）技术。8：设置端口转发策略。9：控制请求icmp服务的流量。10：管理防火墙的富规则。11：管理网卡设备。12：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。13：firewall-config工具的运行状态。 刘遄老师再啰嗦几句。在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存。下面进行动手实践环节。 我们先将当前区域中请求http服务的流量设置为允许，但仅限当前生效。具体配置如图8-3所示。 尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的。在按照图8-4所示的界面配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效（见图8-5）。这与在命令行中执行–reload参数的效果一样。 前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。该技术的应用非常广泛，甚至可以说我们每天都在使用，只不过没有察觉到罢了。比如，当我们通过家中的网关设备（比如无线路由器）访问本书配套站点www.linuxprobe.com时，就用到了SNAT技术。 大家可以看一下在网络中不使用SNAT技术（见图8-6）和使用SNAT技术（见图8-7）时的情况。在图8-6所示的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。在图8-7所示的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。 使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照图8-8进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。 为了让大家直观查看不同工具在实现相同功能的区别，这里使用firewall-config工具重新演示了前面使用firewall-cmd来配置防火墙策略规则，将本机888端口的流量转发到22端口，且要求当前和长期均有效，具体如图8-9和图8-10所示。 配置富规则，让192.168.10.20主机访问到本机的1234端口号，如图8-11所示。 如果生产环境中的服务器有多块网卡在同时提供服务（这种情况很常见），则对内网和对外网提供服务的网卡要选择的防火墙策略区域也是不一样的。也就是说，可以把网卡与防火墙策略区域进行绑定（见图8-12），这样就可以使用不同的防火墙区域策略，对源自不同网卡的流量进行针对性的监控，效果会更好。 最后，刘遄老师想说的是，firewall-config工具真的非常实用，很多原本复杂的长命令被用图形化按钮替代，设置规则也简单明了，足以应对日常工作。所以再次向大家强调配置防火墙策略的原则—只要能实现所需的功能，用什么工具请随君便。 4. 服务的访问控制列表TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。 TCP Wrappers服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。 TCP Wrappers服务的控制列表文件配置起来并不复杂，常用的参数如表4所示。 表4 TCP Wrappers服务的控制列表文件中常用的参数 客户端类型 示例 满足示例的客户端列表 单一主机 192.168.10.10 IP地址为192.168.10.10的主机 指定网段 192.168.10. IP段为192.168.10.0/24的主机 指定网段 192.168.10.0/255.255.255.0 IP段为192.168.10.0/24的主机 指定DNS后缀 .linuxprobe.com 所有DNS后缀为.linuxprobe.com的主机 指定主机名称 www.linuxprobe.com 主机名称为www.linuxprobe.com的主机 指定所有客户端 ALL 所有主机全部包括在内 在配置TCP Wrappers服务时需要遵循两个原则： 编写拒绝策略规则时，填写的是服务名称，而非协议名称； 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。 下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须/etc/hosts.deny文件中修改原有的注释信息）： 12345678910111213141516[root@linuxprobe ~]# vim /etc/hosts.deny## hosts.deny This file contains access rules which are used to# deny connections to network services that either use# the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## The rules in this file can also be set up in# /etc/hosts.allow with a 'deny' option instead.## See 'man 5 hosts_options' and 'man 5 hosts_access'# for information on rule syntax.# See 'man tcpd' for information on tcp_wrapperssshd:*[root@linuxprobe ~]# ssh 192.168.10.10ssh_exchange_identification: read: Connection reset by peer 接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观： 1234567891011121314151617181920[root@linuxprobe ~]# vim /etc/hosts.allow## hosts.allow This file contains access rules which are used to# allow or deny connections to network services that# either use the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## See 'man 5 hosts_options' and 'man 5 hosts_access'# for information on rule syntax.# See 'man tcpd' for information on tcp_wrapperssshd:192.168.10.[root@linuxprobe ~]# ssh 192.168.10.10The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.root@192.168.10.10's password: Last login: Wed May 4 07:56:29 2017[root@linuxprobe ~]#","categories":[{"name":"Linux系统","slug":"Linux系统","permalink":"https://melville.club/categories/Linux系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://melville.club/tags/linux/"},{"name":"网络","slug":"网络","permalink":"https://melville.club/tags/网络/"},{"name":"防火墙","slug":"防火墙","permalink":"https://melville.club/tags/防火墙/"}]},{"title":"Linux下用iperf测试网络时出现unable to connect to server: No route to host","slug":"Linux下用iperf测试网络时出现unable-to-connect-to-server-No-route-to-host","date":"2018-10-23T01:27:01.000Z","updated":"2019-01-16T06:31:43.257Z","comments":true,"path":"/posts/a-2018-10-23-09-27-01.html","link":"","permalink":"https://melville.club/posts/a-2018-10-23-09-27-01.html","excerpt":"Problem为了验证虚拟网卡驱动的性能，需要两台主机之间互相收发数据，我使用iperf工具进行测试，报错“unable to connect to server: No route to host”，但是可以ping通另一台主机。 SolventGoogle了一下，发现是防火墙的问题，需要将防火墙关掉，大部分搜索到的结果都是： 12service iptables stopiptables -F","text":"Problem为了验证虚拟网卡驱动的性能，需要两台主机之间互相收发数据，我使用iperf工具进行测试，报错“unable to connect to server: No route to host”，但是可以ping通另一台主机。 SolventGoogle了一下，发现是防火墙的问题，需要将防火墙关掉，大部分搜索到的结果都是： 12service iptables stopiptables -F 执行此操作后并没有解决问题（我用的是中标麒麟V5.0系统），我就把系统防火墙firewalld全部关闭，问题解决。指令如下：1234systemctl stop firewalldsystemctl disable firewalldsystemctl stop firewalld.servicesystemctl disable firewalld.service 想知道iptables和firewalled有什么区别？请参照《iptables和firewalled的区别》","categories":[{"name":"工具","slug":"工具","permalink":"https://melville.club/categories/工具/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://melville.club/tags/linux/"},{"name":"网络","slug":"网络","permalink":"https://melville.club/tags/网络/"},{"name":"iperf","slug":"iperf","permalink":"https://melville.club/tags/iperf/"}]},{"title":"C语言结构体中char[0]和char[1]的用法","slug":"C语言结构体中char-0-和char-1-的用法","date":"2018-09-18T09:45:22.000Z","updated":"2019-01-24T07:18:44.058Z","comments":true,"path":"/posts/a-2018-09-18-17-45-22.html","link":"","permalink":"https://melville.club/posts/a-2018-09-18-17-45-22.html","excerpt":"1.写在前面我在进行Linux 64位驱动程序兼容32位应用程序的适配过程中，深深的感觉指针操作带来的麻烦，特别是应用层的32位指针传到内核层后，指针大小变成64位，需要进行频繁的大小调整，及其难受。等我快完成所有工作的时候，听一位同事说可以使用char[0]用法来代替指针，我差点一口老血喷出来。“你咋不早说…”。接下来从网上各种google，发现了这种用法的巧妙，特写下此篇文章，以做记录。（PS：还是要感谢我那位同事YYL，让我又get到一个技能^_^） 在结构体最后加char[0]或char[1]的用法是GNU C的扩展，在ISO/IEC 9899-1999里面，这么写是非法的。这种用法在C99中叫做 柔性数组。柔性数组成员前面必须至少有一个其它类型成员。包含柔性数组成员的结构要用malloc进行动态内存分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。","text":"1.写在前面我在进行Linux 64位驱动程序兼容32位应用程序的适配过程中，深深的感觉指针操作带来的麻烦，特别是应用层的32位指针传到内核层后，指针大小变成64位，需要进行频繁的大小调整，及其难受。等我快完成所有工作的时候，听一位同事说可以使用char[0]用法来代替指针，我差点一口老血喷出来。“你咋不早说…”。接下来从网上各种google，发现了这种用法的巧妙，特写下此篇文章，以做记录。（PS：还是要感谢我那位同事YYL，让我又get到一个技能^_^） 在结构体最后加char[0]或char[1]的用法是GNU C的扩展，在ISO/IEC 9899-1999里面，这么写是非法的。这种用法在C99中叫做 柔性数组。柔性数组成员前面必须至少有一个其它类型成员。包含柔性数组成员的结构要用malloc进行动态内存分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 2.引用这种用法的目的 主要是为了方便管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）而如果使用数组，那么只需要一次就可以全部分配出来，反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序。 其实就是分配一段连续的的内存，减少内存的碎片化。 3.用法1234567struct Msg&#123; ... // 其它成员 ... // 其它成员 int nLen; // 一般char data[0]的前面会加一个长度nLen表示data的大小 char data[0]; // char[0]或char[1]必须放在最后&#125;; 我们要知道的一点就是：char data[0] 这个数组是没有元素的，它的地址紧跟着nLen后的地址，如果分配的内存大于结构体的实际大小，那么大出来的那部分就是data的内容。 实际使用时，一般这样用 123int dataBytes = 10; // 此处指定data的数据大小struct Msg *p = (struct Msg *)malloc(sizeof(struct Msg) + dataBytes); // 动态分配p-&gt;nLen = dataBytes; // 把长度赋值给nLen，以方便其它部分使用此结构体 如果还不明白，撸一串代码，一看便知： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// test.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct body1&#123; int a; int b;&#125;__attribute ((packed)) BODY1; //__attribute ((packed))是强制不进行字节对齐typedef struct body2&#123; int len; char *data;&#125;__attribute ((packed)) BODY2;typedef struct body3&#123; int len; char data[0];&#125;__attribute ((packed)) BODY3;typedef struct body4&#123; int len; char data[1];&#125;__attribute ((packed)) BODY4;int main()&#123; BODY1 b1; BODY2 b2; BODY3 b3; BODY4 b4; memset(&amp;b1, 0, sizeof(BODY1)); memset(&amp;b2, 0, sizeof(BODY2)); memset(&amp;b3, 0, sizeof(BODY3)); memset(&amp;b4, 0, sizeof(BODY4)); printf(\"sizeof(b1) = %ld\\n\", sizeof(b1)); printf(\"sizeof(b2) = %ld\\n\", sizeof(b2)); printf(\"sizeof(b3) = %ld\\n\", sizeof(b3)); printf(\"sizeof(b4) = %ld\\n\", sizeof(b4)); printf(\" b2 addr = %p\\n\", &amp;b2); printf(\"b2.data addr = %p\\n\", b2.data); printf(\" b3 addr = %p\\n\", &amp;b3); printf(\"b3.data addr = %p\\n\", b3.data); printf(\" b4 addr = %p\\n\", &amp;b4); printf(\"b4.data addr = %p\\n\", b4.data); return 0;&#125; 程序是在64位系统下编译，运行结果如下: 12345678910sizeof(b1) = 8sizeof(b2) = 12sizeof(b3) = 4sizeof(b4) = 5 b2 addr = 0x7ffded4f3633b2.data addr = (nil) b3 addr = 0x7ffded4f363fb3.data addr = 0x7ffded4f3643 b4 addr = 0x7ffded4f3643b4.data addr = 0x7ffded4f3647 从上面的结果可以看出： char data[0]是不占用任何空间的，而char *data占用了一个指针变量的大小，千万不要把char data[0]当做一个指针，它其实是一个偏移量，这个偏移量指向结构体后紧挨着的空间。 char[1]是占用空间的，如果没加强制不进行字节对齐，则结构体的大小会是8。char[0]和char[1]的作用是相同的。 b3的data地址，是b3结构体开始的地址加上len所占用的4字节的地址，b4也是一样。 4.用指针和char[0]的区别 结构体中使用指针：创建时，系统先为结构体分配内存，再分配指针指向的data的内存。两块内存不连续。释放的时候，先释放指针指向的内存，再释放结构体内存。 结构体中使用char[0]：创建时，系统一起为其分配结构体的内存和data的内存，两块内存是连续的（更确切的说是一块内存）。释放的时候，一次性释放。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://melville.club/categories/Linux/"},{"name":"编程语言","slug":"Linux/编程语言","permalink":"https://melville.club/categories/Linux/编程语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://melville.club/tags/C语言/"},{"name":"结构体","slug":"结构体","permalink":"https://melville.club/tags/结构体/"},{"name":"指针","slug":"指针","permalink":"https://melville.club/tags/指针/"},{"name":"内存","slug":"内存","permalink":"https://melville.club/tags/内存/"}]},{"title":"Linux64位系统兼容32位应用程序","slug":"Linux64位系统兼容32位应用程序","date":"2018-09-18T09:21:40.000Z","updated":"2019-01-16T06:31:39.289Z","comments":true,"path":"/posts/a-2018-09-18-17-21-40.html","link":"","permalink":"https://melville.club/posts/a-2018-09-18-17-21-40.html","excerpt":"1. 问题现象在进行64位驱动兼容32位应用程序的修改中，发现了如下几个问题： 32位应用程序调用ioctl时，返回ENOTTY（inappropriate ioctl for device）错误。经过调试发现根本没调用到内核的ioctl函数。 解决完第一个问题后，应用程序进入了ioctl中，但是用户程序和驱动打印的ioctl命令号不一样，导致在switch的时候，找不到对应命令号。 从用户空间拷贝数据的时候（copy_from_user()）失败。拷贝的数据结构里面含有指针。","text":"1. 问题现象在进行64位驱动兼容32位应用程序的修改中，发现了如下几个问题： 32位应用程序调用ioctl时，返回ENOTTY（inappropriate ioctl for device）错误。经过调试发现根本没调用到内核的ioctl函数。 解决完第一个问题后，应用程序进入了ioctl中，但是用户程序和驱动打印的ioctl命令号不一样，导致在switch的时候，找不到对应命令号。 从用户空间拷贝数据的时候（copy_from_user()）失败。拷贝的数据结构里面含有指针。 2. 问题分析2.1 第一个问题在 Linux kernel 2.6.36 中已经完全删除了 struct file_operations 结构中的 ioctl 函数指针，取而代之的是 unlocked_ioctl。之后的内核版本中，struct file_operations 含有下面两个函数指针： 123456struct file_operations &#123; ... ... long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); ... ...&#125;； 如果是64位用户程序运行在64位的内核上，调用的是unlocked_ioctl; 如果是32位用户程序运行在32位的内核上，调用的也是unlocked_ioctl; 支持64位的驱动必须要实现compat_ioctl，如果没有实现，那么32位的用户程序在64位的内核上执行ioctl时会返回错误 ENOTTY。 要解决第一个问题，就需要在驱动层实现 compat_ioctl. 2.2 第二个问题命令号中的参数部分含有指针，32位用户程序的指针是4字节，64位驱动的指针是8字节，导致最终计算出的命令号不一致。可采用如下方法解决： 尽量避免使用指针类型 提供64位和32位大小一致的结构 先将传入的指针转成64位，使其能进入ioctl函数，在函数内部再对指针进行处理。 2.3 第三个问题由于传入内核的数据结构里面含有指针类型，所以在拷贝的时候，用户态结构和内核态结构的大小就不一样，导致拷贝失败。解决方法如下： 使用compat_ptr()宏转换64位的unsigned long数据类型到32位的地址。 对ioctl函数的参数也要使用compat_ptr()进行转换。 避免使用指针，可用 char[0] 或 char[1] 代替。关于char[0] 和 char[1]的用法，参照这篇文章。","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://melville.club/categories/Linux驱动/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://melville.club/tags/linux/"},{"name":"驱动","slug":"驱动","permalink":"https://melville.club/tags/驱动/"},{"name":"兼容","slug":"兼容","permalink":"https://melville.club/tags/兼容/"}]},{"title":"三层架构：表示层——业务逻辑层——数据访问层","slug":"三层架构","date":"2018-09-12T02:58:00.000Z","updated":"2019-01-16T06:32:04.129Z","comments":true,"path":"/posts/a-2018-09-12-10-58-00.html","link":"","permalink":"https://melville.club/posts/a-2018-09-12-10-58-00.html","excerpt":"1. 什么是三层架构所谓的三层开发就是将系统的整个业务应用划分为 表示层,业务逻辑层,数据访问层，这样有利于系统的开发、维护、部署和扩展。分层是为了实现 “高内聚，低耦合”，采用 “分而治之” 的思想，把问题划分开来各个解决，易于控制、易于延展、易于分配资源。进行软件开发设计，一定要懂得 分而治之 分而治之 分而治之","text":"1. 什么是三层架构所谓的三层开发就是将系统的整个业务应用划分为 表示层,业务逻辑层,数据访问层，这样有利于系统的开发、维护、部署和扩展。分层是为了实现 “高内聚，低耦合”，采用 “分而治之” 的思想，把问题划分开来各个解决，易于控制、易于延展、易于分配资源。进行软件开发设计，一定要懂得 分而治之 分而治之 分而治之 表示层：负责直接跟用户进行交互，一般也就是指系统的界面，用于数据录入，数据显示等。意味着只做与外观显示相关的工作，不属于他的工作不用做。 业务逻辑层：用于做一些有效的验证工作，以更好地保证程序运行的健壮性。如完成数据添加、修改和查询等；不允许指定的文本框中输入空字符串，数据格式是否正确及数据类型验证；用户的权限合法性判断等。通过以上诸多判断以决定是否将操作继续向后传递，尽量保证程序的正常运行。 数据访问层：顾名思义，就是专门跟数据库进行交互，执行数据的添加、删除、修改和显示等。需要强调的是，所有的数据对象只在这一层被引用，除数据层之外的任何地方都不应该出现这样的引用。 ASP.NET可以使用.NET平台快速方便地部署三层架构。ASP.NET革命性的变化是在网页中也使用基于事件的处理，可以指定处理的后台代码文件，可以使用C#、VB、C++和J#作为后台代码的语言。.NET中可以方便的实现组件的装配，后台代码通过命名空间可以方便的使用自己定义的组件。显示层放在ASPX页面中，数据库操作和逻辑层用组件或封装类来实现，这样就很方便的实现了三层架构。 2. 为什么使用三层架构对于一个简单的应用程序来说，代码量不是很多的情况下，一层结构或二层结构开发完全够用，没有必要将其复杂化，如果对一个复杂的大型系统，设计为一层结构或二层结构开发，那么这样的设计存在很严重缺陷。下面会具体介绍，分层开发其实是为大型系统服务的。 在开发过程中，初级程序人员出现相似的功能经常复制代码，那么同样的代码为什么要写那么多次？不但使程序变得冗长，更不利于维护，一个小小的修改或许会涉及很多页面，经常导致异常的产生使程序不能正常运行。最主要的面向对象的思想没有得到丝毫的体现，打着面向对象的幌子却依然走着面向过程的道路。 意识到这样的问题，初级程序人员开始将程序中一些公用的处理程序写成公共方法，封装在类中，供其他程序调用。例如写一个数据操作类，对数据操作进行合理封装，在数据库操作过程中，只要类中的相应方法（数据添加、修改、查询等）可以完成特定的数据操作，这就是数据访问层，不用每次操作数据库时都写那些重复性的数据库操作代码。在新的应用开发中，数据访问层可以直接拿来用。面向对象的三大特性之一的封装性在这里得到了很好的体现。读者现在似乎找到了面向对象的感觉，代码量较以前有了很大的减少，而且修改的时候也比较方便，也实现了代码的重用性。 下面举两个案例，解释一下为什么要使用三层架构。 案例一： 数据库系统软件由于数据量的不断增加，数据库由Access变成了SQLServer数据库，这样原来的数据访问层失效了，数据操作对象发生了变化，并且页面中涉及数据对象的地方也要进行修改，因为原来可能会使用OleDbDataReader对象将数据传递给显示页面，现在都得换成SqlDataReader对象，SQLServer和Access支持的数据类型也不一致，在显示数据时进行的数据转换也要进行修改，这是其中一种情况。 案例二： 由于特殊情况需要，把Web形式的项目改造成Windows应用，此时需要做多少修改呢？如果在Aspx.cs中占据了大量代码，或者还有部分代码存在于Aspx中，那么整个系统是否需要重新来开发呢？ 在上面的案例中是否体会到了没有分层开发模式的缺陷呢？是否碰到过这样的情况呢？这都是由设计不合理造成的，多层开发架构的出现可以很好地解决该问题，通过程序架构进行合理的分层，将极大地提高程序的通用性。 3. 使用三层架构开发的优点使用三层架构开发有以下优点： 从开发角度和应用角度来看，三层架构比二层架构或单层架构都有更大的优势。三层架构适合团队开发，每人可以有不同的分工，协同工作使效率倍增。开发二层或单层应用程序时，每个开发人员都应对系统有较深的理解，能力要求很高，开发三层应用程序时，则可以结合多方面的人才，只需少数人对系统全面了解即可，从一定程度降低了开发的难度。 三层架构可以更好的支持分布式计算环境。逻辑层的应用程序可以在多个计算机上运行，充分利用网络的计算功能。分布式计算的潜力巨大，远比升级CPU有效。美国人曾利用分式计算解密，几个月就破解了据称永远都破解不了的密码。 三层架构的最大优点是它的安全性。用户只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。 4. 三层架构的种类目前，团队开发人员在开发项目时，大多都使用分层开发架构设计，最常见的就是三层架构，目的在于使各个层之间只能够被它相邻的层产生影响，但是这个限制常常在使用多层开发的时候被违反，这对系统的开发是有害的。三层架构按驱动模式可划分三种：数据层驱动模式、陈述层驱动模式和隔离驱动模式，其中隔离驱动模式开发最为重要。下面通过三种模式的对比，介绍隔离驱动模式的重要性。 数据层驱动模式 所谓的数据层驱动模式，就是先设计数据层，陈述层围绕数据层展开，一旦完成了数据层和陈述层，业务层就围绕数据层展开。因为陈述层是围绕数据层展开的，这将会使陈述层中的约束不准确，并且限制了业务层的变更。由于业务层受到限制，一些简单变化可以通过SQL查询和存储过程来实现。 这种模式非常的普遍，它和传统的客户服务端开发相似，并且是围绕已经存在的数据库设计的。由于陈述层是围绕数据层设计的，它常常是凭直觉模仿数据层的实际结构。 常常存在一种额外的反馈循环在陈述层到数据之间，当在设计陈述层不容易实现的时候常常会去修改数据层，也就形成了这种反馈循环。开发者请求修改数据库方便陈述层的开发，但是对数据层的设计却是有害的。这种改变是人为的而没考虑到其他需求的限制。这种修改经常会违反至少损害数据的特有规则，导致不必要的数据冗余和数据的非标准化。 陈述层驱动模式 陈述层驱动模式是数据层围绕陈述层展开的。业务层的完成一般是通过简单的SQL查询和很少的变化或者隔离。由于数据库的设计是为了陈述层的方便，并非从数据层设计方面考虑，所以数据库的设计在性能上通常很低。 隔离驱动模式 用隔离驱动模式设计，陈述层和数据层被独立的开发，常常是平行开发。这两层在设计时没有任何的相互干扰，所以不会存在人为的约束和有害的设计元素。当两层都设计完成后，再设计业务层。业务层的责任就是在没有对数据层和陈述层的需求变化的基础上完成所有的转换。 因为现在陈述层和数据层是完全独立的，当业务层需求改变的时候，陈述层和数据层都可以做相应的修改而不影响对方。改变两个在物理上不相邻的层不会直接对其他层产生影响或发生冲突。这就允许数据层结构的调整或者陈述层根据用户的需求做相应的变化，而不需要系统做大的调整或者修改。下表将对这3种驱动模式进行对比。 数据层驱动模式 陈述层驱动模式 隔离驱动模式 数据库 1. 很容易设计2.产生负面影响3.很难改变数据层，因为它和陈述层紧密绑定 1.数据库设计很糟2.严重的不规范化设计3.其他系统不易使用4.很难改变数据层，由于它跟陈述层紧密绑定 1.优化设计2.集中设计数据库，陈述层对它影响很小 业务需求 常常不能适应业务需求变化 常常适应业务需求变化 适应需求变化 用户界面 是围绕数据层而不是围绕用户，不易修改 适合用户扩展界面 适合用户扩展界面 扩展性 通常可扩张，但是常常在用户界面需要比较多的重写以满足数据库的结构，同时数据库可能需要存储一些冗余的字段 完整性的扩张很难，常常只有通过“剪切，粘贴”函数来实现 很容易扩展 综上所述，很容易看出隔离驱动模式的优点，隔离驱动模式设计可以极大地提高程序的扩展性。","categories":[{"name":"架构","slug":"架构","permalink":"https://melville.club/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://melville.club/tags/架构/"},{"name":"系统","slug":"系统","permalink":"https://melville.club/tags/系统/"},{"name":"软件","slug":"软件","permalink":"https://melville.club/tags/软件/"}]},{"title":"学习使用Markdown","slug":"Markdown","date":"2018-09-06T07:46:35.000Z","updated":"2019-01-16T06:31:47.166Z","comments":true,"path":"/posts/a-2018-09-06-15-46-35.html","link":"","permalink":"https://melville.club/posts/a-2018-09-06-15-46-35.html","excerpt":"1 关于MarkdownMarkdown是一种轻量级标记语言，它的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的HTML(或XHTML)”。 优点 易读 易读是指Markdown文件（即 .md 文件）容易阅读，与HTML相比，它没有各种繁杂的尖括号&lt;&gt;和缩进。整体简洁美观。 易写 使用Markdown可以让你专注于文字，不用像office软件一样需要用鼠标疯狂点击那些排版按钮，可以做到手不离键盘且快速高效的将写作与排版一气呵成。而且Markdown语法简单，花半个小时就能学会基本语法。 缺点 标准不统一 目前Markdown语法众多、编辑器层出不穷，每个编辑器支持的语法也不同，这就导致在一个编辑器上写的md文件，放到其它编辑器上，出现排版混乱，甚至是不支持某些语法的现象。这就是人们所说的 “方言现象”，这也是目前Markdown最突出的问题。 图片支持不够 不能直接显示图片，不能调整大小。且不同编辑器对图片的处理也有所不同。 表格支持不够 原生的Markdown是不支持表格的，但现在大部分编辑器都支持简单的表格，也有支持复杂表格的语法，但是书写困难，且不被大多数编辑器支持。 占用特殊字符 Markdown的语法占用了一些特殊字符，导致想在文本中输入特殊字符的时候，需要进行转义操作。","text":"1 关于MarkdownMarkdown是一种轻量级标记语言，它的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的HTML(或XHTML)”。 优点 易读 易读是指Markdown文件（即 .md 文件）容易阅读，与HTML相比，它没有各种繁杂的尖括号&lt;&gt;和缩进。整体简洁美观。 易写 使用Markdown可以让你专注于文字，不用像office软件一样需要用鼠标疯狂点击那些排版按钮，可以做到手不离键盘且快速高效的将写作与排版一气呵成。而且Markdown语法简单，花半个小时就能学会基本语法。 缺点 标准不统一 目前Markdown语法众多、编辑器层出不穷，每个编辑器支持的语法也不同，这就导致在一个编辑器上写的md文件，放到其它编辑器上，出现排版混乱，甚至是不支持某些语法的现象。这就是人们所说的 “方言现象”，这也是目前Markdown最突出的问题。 图片支持不够 不能直接显示图片，不能调整大小。且不同编辑器对图片的处理也有所不同。 表格支持不够 原生的Markdown是不支持表格的，但现在大部分编辑器都支持简单的表格，也有支持复杂表格的语法，但是书写困难，且不被大多数编辑器支持。 占用特殊字符 Markdown的语法占用了一些特殊字符，导致想在文本中输入特殊字符的时候，需要进行转义操作。 使用群体 喜欢写博客的人 经常阅读书写各种技术文档的技术人员 混迹于各种技术论坛和社区的程序员 追求简洁排版、快速编辑的文字工作者 2 基本语法2.1 标题只需要在文本前面加上 # 号即可(注意#号后面有一个空格)，二级标题加两个 ## ，三级标题加三个 ### ，以此类推，最多六级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下： 2.2 列表1. 无序列表使用 *，+，- 表示无序列表。列表可以嵌套，上一级和下一级之间敲三个空格即可，建议相同级别的列表项使用相同的符号，并且保持缩进一致，如一级列表用 *，二级列表用 +，三级列表用 - 。 （注意后面需要加空格） 示例： 1234567* 无序列表项1 + 无序列表项1.1 - 无序列表项1.1.1 + 无序列表项1.2 - 无序列表项1.2.1* 无序列表项2* 无序列表项3 效果如下： 无序列表项1 无序列表项1.1 无序列表项1.1.1 无序列表项1.2 无序列表项1.2.1 无序列表项2 无序列表项3 2. 有序列表使用数字和点表示有序列表。（注意后面需要加空格） 示例： 1231. 有序列表项2. 有序列表项3. 有序列表项 效果如下： 有序列表项 有序列表项 有序列表项 2.3 字体1234*斜体***加粗*****斜体加粗***~~删除线~~ 效果如下： 斜体 加粗 斜体加粗 删除线 2.4 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，貌似可以一直嵌套下去。 1234&gt; 引用&gt;&gt; 引用&gt;&gt;&gt; 引用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用 效果如下： 引用 引用 引用 引用 2.5 分割线使用三个或三个以上的 - 或 *。示例： 1234-----------*********** 效果如下： 2.6 超链接加入超链接的格式如下： 1[链接名字](链接地址, &quot;链接title&quot;) 其中链接title可以不填。例如： 1[百度一下](https://www.baidu.com/) 注意：不能直接写成 www.baidu.com ，需要加 https://或http:// 效果如下：百度一下 2.7 插入图片插入图片的格式如下： 1![图片描述](图片地址) 其中图片title可以不填。例如： 1![tree](http://hru.com/blog/180910/84.jpg?imageim) 效果如下： 一般情况下，我们插入的图片大小都不一样，如果像上面的图片一样过大，就会铺满整个屏幕，显示效果就会大打折扣。可惜Markdown没有能处理图片大小的语法（Markdown只注重文字，不注重精细的排版）。天无绝人之路，好在Markdown支持内嵌HTML语句，可以使用HTML来实现图片大小的控制。语法如下： 123&lt;img src=\"http://hru.com/blog/180910/84.jpg?imageim\" width=30% height=30%&gt;width：宽度比例 height：高度比例。width和height也可以填写具体数值 效果如下： 如果有使用七牛作为图床的同学，可以查看七牛API文档，他们提供了更多形式的图片处理接口，这里不做过多介绍。 2.8 表格下面是一般表格的书写格式： 1234表头|表头|表头---|---|---内容|内容|内容内容|内容|内容 表的两边可以加 | 将表包围起来，也可以不加，效果一样，如下所示： 1234|表头|表头|表头||---|---|---||内容|内容|内容||内容|内容|内容| Markdown默认表的内容是左对齐，标题是居中对齐，我们可以根据需要，使用 : 来进行对齐。示例： 123456789左对齐|居中|右对齐:---|:---:|---:内容|内容|内容内容|内容|内容&quot;-&quot;短线每一栏加1个就够了，这里为了对齐，都加了3个。左边加&quot;:&quot;表示文字居左。两边加&quot;:&quot;表示文字居中。右边加&quot;:&quot;表示文字居右。 效果如下： 左对齐标题 居中标题 右对齐标题 内容 内容 内容 内容 内容 内容 2.9 代码Markdown可以内嵌代码，还支持代码高亮，不同开发语言有不同的高亮形式。 语法如下： 1234567891011单行代码使用两个 ` 将代码包围起来：&gt; `代码`多行代码使用两个 ``` 加代码语言标识：&gt; (``` 语言标识)&gt; 代码块&gt; (```)上面的括号和&gt;不用写，这里为了方便展示多加了，请忽略 语言标识是对各种语言的分类，如：python，c，bash，java，php，sql…… 效果如下： 单行代码： unsigned int a; 多行代码(语言标识：C)：123456int main()&#123; int a = 9; printf(\"%d\\n\", a); return 0;&#125; 2.10 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：12345678- [ ] 一级任务 - [ ] 二级任务 - [x] 二级任务 - [x] 二级任务 - [x] 三级任务 - [x] 三级任务- [ ] 一级任务 - [ ] 二级任务 效果如下： 一级任务 二级任务 二级任务 二级任务 三级任务 三级任务 一级任务 二级任务 2.11 修改文字颜色和格式我们写文章的时候，可能需要强调一些文字（颜色、大小、字体、位置等），让读者引起注意，但是Markdown里面没有修改文字颜色的语法，这就需要用HTML语法来实现修改文字颜色。语法如下： a. 颜色、大小、字体修改12345678910&lt;font 格式&gt; 文字内容 &lt;/font&gt;其中，“格式”的语法如下：更改颜色：color=#FF0000 //色号是十六进制的更改字体：face=\"宋体\"更改大小：size= 5例如：&lt;font face=\"宋体\"&gt;这段文字是宋体&lt;/font&gt;&lt;font color=#FF0000 face=\"黑体\" size=30&gt;这段文字是红色，黑体，大小30&lt;/font&gt; 这段文字是宋体这段文字是红色，黑体，大小30 b. 文字居中1&lt;center&gt; 文字居中 &lt;/center&gt; 这是一段居中的文字 3、支持Markdown语法的软件或网站编辑软件： atom —— 21世纪黑客文本编辑器，里面有各种插件，程序猿专用软件，也是我目前在用的编辑软件。 Visual Studio Code —— 一心想要统治地球的软件，对Markdown语法要求严格，经常会出现红波浪线和绿波浪线。 MarkdownPad —— 一款全功能的编辑器，被很多人称赞为windows 平台最好用的markdown编辑器。 Sublime Text 2 —— 界面简约大方，定位专业。 Smark MdCharm 网站（在线编辑器）： 简书 —— 一个很好的博客平台，简约美观，写文章时可以直接拖入图片生成链接。 dillinger —— 支持md, html, pdf 文件导出。支持dropbox, onedrive，google drive, github. Cmd Markdown 小书匠编辑器 如果上面没有适合你的编辑器，请自行上网查找其它的编辑器。","categories":[{"name":"语言","slug":"语言","permalink":"https://melville.club/categories/语言/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://melville.club/tags/markdown/"}]}]}
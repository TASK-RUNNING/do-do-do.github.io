{"meta":{"title":"Melville'blog","subtitle":null,"description":"开源大法好","author":"Melville","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-10-23T06:00:00.124Z","updated":"2018-10-23T05:59:34.147Z","comments":true,"path":"baidu_verify_3nmNAJJ0OT.html","permalink":"http://yoursite.com/baidu_verify_3nmNAJJ0OT.html","excerpt":"","text":"3nmNAJJ0OT"},{"title":"自述","date":"2018-09-05T07:25:14.000Z","updated":"2018-09-06T08:17:38.947Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"为建设中国特色社会主义贡献力量，革命尚未成功，同志仍需努力。 ————爱老婆，爱生活"},{"title":"分类","date":"2018-09-05T07:20:09.000Z","updated":"2018-09-05T07:53:31.030Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-05T07:22:10.000Z","updated":"2018-09-05T07:46:25.756Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"baidu_verify_3nmNAJJ0OT","date":"2018-10-23T06:13:40.467Z","updated":"2018-10-23T06:14:15.552Z","comments":true,"path":"baidu_verify_3nmNAJJ0OT.html","link":"","permalink":"http://yoursite.com/baidu_verify_3nmNAJJ0OT.html","excerpt":"","text":"3nmNAJJ0OT","categories":[],"tags":[]},{"title":"iptables和firewalled的区别","slug":"iptables和firewalled的区别","date":"2018-10-23T02:15:57.000Z","updated":"2018-10-23T05:08:28.850Z","comments":true,"path":"iptables和firewalled的区别.html","link":"","permalink":"http://yoursite.com/iptables和firewalled的区别.html","excerpt":"简述保证数据的安全性是继可用性之后最为重要的一项工作，防火墙技术作为公网与内网之间的保护屏障，起着至关重要的作用。面对同学们普遍不了解在红帽RHEL7系统中新旧两款防火墙的差异，刘遄老师决定先带领读者正确的认识在红帽RHEL7系统中firewalld防火墙服务与iptables防火墙服务之间的关系，从理论和事实层面剖析真相。 本章节内将会分别使用iptables、firewall-cmd、firewall-config和Tcp_wrappers等防火墙策略配置服务来完成数十个根据真实工作需求而设计的防火墙策略配置实验，让同学们不仅能够熟练的对请求数据包流量进行过滤，还能够基于服务程序进行允许和关闭操作，做到保证Linux系统安全万无一失。 1. 防火墙管理工具保证数据的安全性是继可用性之后最为重要的一项工作，众所周知外部公网相比企业内网更加的“罪恶丛生”，因此防火墙技术作为公网与内网之间的保护屏障，虽然有软件或硬件之分，但主要功能都是依据策略对外部请求进行过滤。防火墙技术能够做到监控每一个数据包并判断是否有相应的匹配策略规则，直到匹配到其中一条策略规则或执行默认策略为止，防火墙策略可以基于来源地址、请求动作或协议等信息来定制，最终仅让合法的用户请求流入到内网中，其余的均被丢弃。","text":"简述保证数据的安全性是继可用性之后最为重要的一项工作，防火墙技术作为公网与内网之间的保护屏障，起着至关重要的作用。面对同学们普遍不了解在红帽RHEL7系统中新旧两款防火墙的差异，刘遄老师决定先带领读者正确的认识在红帽RHEL7系统中firewalld防火墙服务与iptables防火墙服务之间的关系，从理论和事实层面剖析真相。 本章节内将会分别使用iptables、firewall-cmd、firewall-config和Tcp_wrappers等防火墙策略配置服务来完成数十个根据真实工作需求而设计的防火墙策略配置实验，让同学们不仅能够熟练的对请求数据包流量进行过滤，还能够基于服务程序进行允许和关闭操作，做到保证Linux系统安全万无一失。 1. 防火墙管理工具保证数据的安全性是继可用性之后最为重要的一项工作，众所周知外部公网相比企业内网更加的“罪恶丛生”，因此防火墙技术作为公网与内网之间的保护屏障，虽然有软件或硬件之分，但主要功能都是依据策略对外部请求进行过滤。防火墙技术能够做到监控每一个数据包并判断是否有相应的匹配策略规则，直到匹配到其中一条策略规则或执行默认策略为止，防火墙策略可以基于来源地址、请求动作或协议等信息来定制，最终仅让合法的用户请求流入到内网中，其余的均被丢弃。 在红帽RHEL7系统中Firewalld服务取代了Iptables服务，对于接触Linux系统比较早或学习过红帽RHEL6系统的读者来讲，突然改用Firewalld服务后确实不免会有些抵触心理，或许会觉得Firewalld服务是一次不小的改变。但其实Iptables服务与Firewalld服务都不是真正的防火墙，它们都只是用来定义防火墙策略功能的“防火墙管理工具”而已，iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实同时有多个防火墙管理工具共同存在，它们的作用都是为了方便运维人员管理Linux系统的防火墙策略，而咱们只要配置妥当其中一个就足够了。虽然各个工具之间各有优劣特色，但对于防火墙策略的配置思路上是保持一致的，同学们甚至可以不用完全掌握本章节内的知识，而是在这诸多个防火墙管理工具中任选一款来学透即可，完全能够满足日常的工作所需。","categories":[{"name":"Linux系统","slug":"Linux系统","permalink":"http://yoursite.com/categories/Linux系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"防火墙","slug":"防火墙","permalink":"http://yoursite.com/tags/防火墙/"}]},{"title":"Linux下用iperf测试网络时出现unable to connect to server: No route to host","slug":"Linux下用iperf测试网络时出现unable-to-connect-to-server-No-route-to-host","date":"2018-10-23T01:27:01.000Z","updated":"2018-10-23T05:08:11.397Z","comments":true,"path":"Linux下用iperf测试网络时出现unable-to-connect-to-server-No-route-to-host.html","link":"","permalink":"http://yoursite.com/Linux下用iperf测试网络时出现unable-to-connect-to-server-No-route-to-host.html","excerpt":"Problem为了验证虚拟网卡驱动的性能，需要两台主机之间互相收发数据，我使用iperf工具进行测试，报错“unable to connect to server: No route to host”，但是可以ping通另一台主机。 SolventGoogle了一下，发现是防火墙的问题，需要将防火墙关掉，大部分搜索到的结果都是： 1iptables -F 执行此操作后并没有解决问题（我用的是中标麒麟V5.0系统），我就把系统防火墙firewalld全部关闭，问题解决。指令如下：","text":"Problem为了验证虚拟网卡驱动的性能，需要两台主机之间互相收发数据，我使用iperf工具进行测试，报错“unable to connect to server: No route to host”，但是可以ping通另一台主机。 SolventGoogle了一下，发现是防火墙的问题，需要将防火墙关掉，大部分搜索到的结果都是： 1iptables -F 执行此操作后并没有解决问题（我用的是中标麒麟V5.0系统），我就把系统防火墙firewalld全部关闭，问题解决。指令如下：1234systemctl stop firewalldsystemctl disable firewalldsystemctl stop firewalld.servicesystemctl disable firewalld.service 想知道iptables和firewalled有什么区别？请参照《iptables和firewalled的区别》","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"iperf","slug":"iperf","permalink":"http://yoursite.com/tags/iperf/"}]},{"title":"","slug":"googled81f063c4dc7b3b9","date":"2018-09-21T02:08:54.499Z","updated":"2018-09-21T02:10:16.051Z","comments":true,"path":"googled81f063c4dc7b3b9.html","link":"","permalink":"http://yoursite.com/googled81f063c4dc7b3b9.html","excerpt":"","text":"google-site-verification: googled81f063c4dc7b3b9.html","categories":[],"tags":[]},{"title":"C语言结构体中char[0]和char[1]的用法","slug":"C语言结构体中char-0-和char-1-的用法","date":"2018-09-18T09:45:22.000Z","updated":"2018-10-23T05:08:46.665Z","comments":true,"path":"C语言结构体中char-0-和char-1-的用法.html","link":"","permalink":"http://yoursite.com/C语言结构体中char-0-和char-1-的用法.html","excerpt":"1.写在前面我在进行Linux 64位驱动程序兼容32位应用程序的适配过程中，深深的感觉指针操作带来的麻烦，特别是应用层的32位指针传到内核层后，指针大小变成64位，需要进行频繁的大小调整，及其难受。等我快完成所有工作的时候，听一位同事说可以使用char[0]用法来代替指针，我差点一口老血喷出来。“你咋不早说…”。接下来从网上各种google，发现了这种用法的巧妙，特写下此篇文章，以做记录。（PS：还是要感谢我那位同事YYL，让我又get到一个技能^_^） 在结构体最后加char[0]或char[1]的用法是GNU C的扩展，在ISO/IEC 9899-1999里面，这么写是非法的。这种用法在C99中叫做 柔性数组。柔性数组成员前面必须至少有一个其它类型成员。包含柔性数组成员的结构要用malloc进行动态内存分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。","text":"1.写在前面我在进行Linux 64位驱动程序兼容32位应用程序的适配过程中，深深的感觉指针操作带来的麻烦，特别是应用层的32位指针传到内核层后，指针大小变成64位，需要进行频繁的大小调整，及其难受。等我快完成所有工作的时候，听一位同事说可以使用char[0]用法来代替指针，我差点一口老血喷出来。“你咋不早说…”。接下来从网上各种google，发现了这种用法的巧妙，特写下此篇文章，以做记录。（PS：还是要感谢我那位同事YYL，让我又get到一个技能^_^） 在结构体最后加char[0]或char[1]的用法是GNU C的扩展，在ISO/IEC 9899-1999里面，这么写是非法的。这种用法在C99中叫做 柔性数组。柔性数组成员前面必须至少有一个其它类型成员。包含柔性数组成员的结构要用malloc进行动态内存分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 2.引用这种用法的目的 主要是为了方便管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）而如果使用数组，那么只需要一次就可以全部分配出来，反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序。 其实就是分配一段连续的的内存，减少内存的碎片化。 3.用法1234567struct Msg&#123; ... // 其它成员 ... // 其它成员 int nLen; // 一般char data[0]的前面会加一个长度nLen表示data的大小 char data[0]; // char[0]或char[1]必须放在最后&#125;; 我们要知道的一点就是：char data[0] 这个数组是没有元素的，它的地址紧跟着nLen后的地址，如果分配的内存大于结构体的实际大小，那么大出来的那部分就是data的内容。 实际使用时，一般这样用 123int dataBytes = 10; // 此处指定data的数据大小struct Msg *p = (struct Msg *)malloc(sizeof(struct Msg) + dataBytes); // 动态分配p-&gt;nLen = dataBytes; // 把长度赋值给nLen，以方便其它部分使用此结构体 如果还不明白，撸一串代码，一看便知： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// test.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct body1&#123; int a; int b;&#125;__attribute ((packed)) BODY1; //__attribute ((packed))是强制不进行字节对齐typedef struct body2&#123; int len; char *data;&#125;__attribute ((packed)) BODY2;typedef struct body3&#123; int len; char data[0];&#125;__attribute ((packed)) BODY3;typedef struct body4&#123; int len; char data[1];&#125;__attribute ((packed)) BODY4;int main()&#123; BODY1 b1; BODY2 b2; BODY3 b3; BODY4 b4; memset(&amp;b1, 0, sizeof(BODY1)); memset(&amp;b2, 0, sizeof(BODY2)); memset(&amp;b3, 0, sizeof(BODY3)); memset(&amp;b4, 0, sizeof(BODY4)); printf(\"sizeof(b1) = %ld\\n\", sizeof(b1)); printf(\"sizeof(b2) = %ld\\n\", sizeof(b2)); printf(\"sizeof(b3) = %ld\\n\", sizeof(b3)); printf(\"sizeof(b4) = %ld\\n\", sizeof(b4)); printf(\" b2 addr = %p\\n\", &amp;b2); printf(\"b2.data addr = %p\\n\", b2.data); printf(\" b3 addr = %p\\n\", &amp;b3); printf(\"b3.data addr = %p\\n\", b3.data); printf(\" b4 addr = %p\\n\", &amp;b4); printf(\"b4.data addr = %p\\n\", b4.data); return 0;&#125; 程序是在64位系统下编译，运行结果如下: 12345678910sizeof(b1) = 8sizeof(b2) = 12sizeof(b3) = 4sizeof(b4) = 5 b2 addr = 0x7ffded4f3633b2.data addr = (nil) b3 addr = 0x7ffded4f363fb3.data addr = 0x7ffded4f3643 b4 addr = 0x7ffded4f3643b4.data addr = 0x7ffded4f3647 从上面的结果可以看出： char data[0]是不占用任何空间的，而char *data占用了一个指针变量的大小，千万不要把char data[0]当做一个指针，它其实是一个偏移量，这个偏移量指向结构体后紧挨着的空间。 char[1]是占用空间的，如果没加强制不进行字节对齐，则结构体的大小会是8。char[0]和char[1]的作用是相同的。 b3的data地址，是b3结构体开始的地址加上len所占用的4字节的地址，b4也是一样。 4.用指针和char[0]的区别 结构体中使用指针：创建时，系统先为结构体分配内存，再分配指针指向的data的内存。两块内存不连续。释放的时候，先释放指针指向的内存，再释放结构体内存。 结构体中使用char[0]：创建时，系统一起为其分配结构体的内存和data的内存，两块内存是连续的（更确切的说是一块内存）。释放的时候，一次性释放。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://yoursite.com/categories/编程语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C语言/"},{"name":"结构体","slug":"结构体","permalink":"http://yoursite.com/tags/结构体/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/指针/"},{"name":"内存","slug":"内存","permalink":"http://yoursite.com/tags/内存/"}]},{"title":"Linux64位系统兼容32位应用程序","slug":"Linux64位系统兼容32位应用程序","date":"2018-09-18T09:21:40.000Z","updated":"2018-10-23T05:08:19.018Z","comments":true,"path":"Linux64位系统兼容32位应用程序.html","link":"","permalink":"http://yoursite.com/Linux64位系统兼容32位应用程序.html","excerpt":"1. 问题现象在进行64位驱动兼容32位应用程序的修改中，发现了如下几个问题： 32位应用程序调用ioctl时，返回ENOTTY（inappropriate ioctl for device）错误。经过调试发现根本没调用到内核的ioctl函数。 解决完第一个问题后，应用程序进入了ioctl中，但是用户程序和驱动打印的ioctl命令号不一样，导致在switch的时候，找不到对应命令号。 从用户空间拷贝数据的时候（copy_from_user()）失败。拷贝的数据结构里面含有指针。 2. 问题分析2.1 第一个问题在 Linux kernel 2.6.36 中已经完全删除了 struct file_operations 结构中的 ioctl 函数指针，取而代之的是 unlocked_ioctl。之后的内核版本中，struct file_operations 含有下面两个函数指针：","text":"1. 问题现象在进行64位驱动兼容32位应用程序的修改中，发现了如下几个问题： 32位应用程序调用ioctl时，返回ENOTTY（inappropriate ioctl for device）错误。经过调试发现根本没调用到内核的ioctl函数。 解决完第一个问题后，应用程序进入了ioctl中，但是用户程序和驱动打印的ioctl命令号不一样，导致在switch的时候，找不到对应命令号。 从用户空间拷贝数据的时候（copy_from_user()）失败。拷贝的数据结构里面含有指针。 2. 问题分析2.1 第一个问题在 Linux kernel 2.6.36 中已经完全删除了 struct file_operations 结构中的 ioctl 函数指针，取而代之的是 unlocked_ioctl。之后的内核版本中，struct file_operations 含有下面两个函数指针：123456struct file_operations &#123; ... ... long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); ... ...&#125;； 如果是64位用户程序运行在64位的内核上，调用的是unlocked_ioctl; 如果是32位用户程序运行在32位的内核上，调用的也是unlocked_ioctl; 支持64位的驱动必须要实现compat_ioctl，如果没有实现，那么32位的用户程序在64位的内核上执行ioctl时会返回错误 ENOTTY。 要解决第一个问题，就需要在驱动层实现 compat_ioctl. 2.2 第二个问题命令号中的参数部分含有指针，32位用户程序的指针是4字节，64位驱动的指针是8字节，导致最终计算出的命令号不一致。可采用如下方法解决： 尽量避免使用指针类型 提供64位和32位大小一致的结构 先将传入的指针转成64位，使其能进入ioctl函数，在函数内部再对指针进行处理。 2.3 第三个问题由于传入内核的数据结构里面含有指针类型，所以在拷贝的时候，用户态结构和内核态结构的大小就不一样，导致拷贝失败。解决方法如下： 使用compat_ptr()宏转换64位的unsigned long数据类型到32位的地址。 对ioctl函数的参数也要使用compat_ptr()进行转换。 避免使用指针，可用 char[0] 或 char[1] 代替。关于char[0] 和 char[1]的用法，参照这篇文章。","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"http://yoursite.com/categories/Linux驱动/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"驱动","slug":"驱动","permalink":"http://yoursite.com/tags/驱动/"},{"name":"兼容","slug":"兼容","permalink":"http://yoursite.com/tags/兼容/"}]},{"title":"三层架构：表示层——业务逻辑层——数据访问层","slug":"三层架构","date":"2018-09-12T02:58:00.000Z","updated":"2018-09-13T05:19:18.208Z","comments":true,"path":"三层架构.html","link":"","permalink":"http://yoursite.com/三层架构.html","excerpt":"1. 什么是三层架构所谓的三层开发就是将系统的整个业务应用划分为 表示层,业务逻辑层,数据访问层，这样有利于系统的开发、维护、部署和扩展。分层是为了实现 “高内聚，低耦合”，采用 “分而治之” 的思想，把问题划分开来各个解决，易于控制、易于延展、易于分配资源。 进行软件开发设计，一定要懂得 分而治之 分而治之 分而治之 表示层：负责直接跟用户进行交互，一般也就是指系统的界面，用于数据录入，数据显示等。意味着只做与外观显示相关的工作，不属于他的工作不用做。 业务逻辑层：用于做一些有效的验证工作，以更好地保证程序运行的健壮性。如完成数据添加、修改和查询等；不允许指定的文本框中输入空字符串，数据格式是否正确及数据类型验证；用户的权限合法性判断等。通过以上诸多判断以决定是否将操作继续向后传递，尽量保证程序的正常运行。 数据访问层：顾名思义，就是专门跟数据库进行交互，执行数据的添加、删除、修改和显示等。需要强调的是，所有的数据对象只在这一层被引用，除数据层之外的任何地方都不应该出现这样的引用。","text":"1. 什么是三层架构所谓的三层开发就是将系统的整个业务应用划分为 表示层,业务逻辑层,数据访问层，这样有利于系统的开发、维护、部署和扩展。分层是为了实现 “高内聚，低耦合”，采用 “分而治之” 的思想，把问题划分开来各个解决，易于控制、易于延展、易于分配资源。 进行软件开发设计，一定要懂得 分而治之 分而治之 分而治之 表示层：负责直接跟用户进行交互，一般也就是指系统的界面，用于数据录入，数据显示等。意味着只做与外观显示相关的工作，不属于他的工作不用做。 业务逻辑层：用于做一些有效的验证工作，以更好地保证程序运行的健壮性。如完成数据添加、修改和查询等；不允许指定的文本框中输入空字符串，数据格式是否正确及数据类型验证；用户的权限合法性判断等。通过以上诸多判断以决定是否将操作继续向后传递，尽量保证程序的正常运行。 数据访问层：顾名思义，就是专门跟数据库进行交互，执行数据的添加、删除、修改和显示等。需要强调的是，所有的数据对象只在这一层被引用，除数据层之外的任何地方都不应该出现这样的引用。 ASP.NET可以使用.NET平台快速方便地部署三层架构。ASP.NET革命性的变化是在网页中也使用基于事件的处理，可以指定处理的后台代码文件，可以使用C#、VB、C++和J#作为后台代码的语言。.NET中可以方便的实现组件的装配，后台代码通过命名空间可以方便的使用自己定义的组件。显示层放在ASPX页面中，数据库操作和逻辑层用组件或封装类来实现，这样就很方便的实现了三层架构。 2. 为什么使用三层架构对于一个简单的应用程序来说，代码量不是很多的情况下，一层结构或二层结构开发完全够用，没有必要将其复杂化，如果对一个复杂的大型系统，设计为一层结构或二层结构开发，那么这样的设计存在很严重缺陷。下面会具体介绍，分层开发其实是为大型系统服务的。 在开发过程中，初级程序人员出现相似的功能经常复制代码，那么同样的代码为什么要写那么多次？不但使程序变得冗长，更不利于维护，一个小小的修改或许会涉及很多页面，经常导致异常的产生使程序不能正常运行。最主要的面向对象的思想没有得到丝毫的体现，打着面向对象的幌子却依然走着面向过程的道路。 意识到这样的问题，初级程序人员开始将程序中一些公用的处理程序写成公共方法，封装在类中，供其他程序调用。例如写一个数据操作类，对数据操作进行合理封装，在数据库操作过程中，只要类中的相应方法（数据添加、修改、查询等）可以完成特定的数据操作，这就是数据访问层，不用每次操作数据库时都写那些重复性的数据库操作代码。在新的应用开发中，数据访问层可以直接拿来用。面向对象的三大特性之一的封装性在这里得到了很好的体现。读者现在似乎找到了面向对象的感觉，代码量较以前有了很大的减少，而且修改的时候也比较方便，也实现了代码的重用性。 下面举两个案例，解释一下为什么要使用三层架构。 案例一： 数据库系统软件由于数据量的不断增加，数据库由Access变成了SQLServer数据库，这样原来的数据访问层失效了，数据操作对象发生了变化，并且页面中涉及数据对象的地方也要进行修改，因为原来可能会使用OleDbDataReader对象将数据传递给显示页面，现在都得换成SqlDataReader对象，SQLServer和Access支持的数据类型也不一致，在显示数据时进行的数据转换也要进行修改，这是其中一种情况。 案例二： 由于特殊情况需要，把Web形式的项目改造成Windows应用，此时需要做多少修改呢？如果在Aspx.cs中占据了大量代码，或者还有部分代码存在于Aspx中，那么整个系统是否需要重新来开发呢？ 在上面的案例中是否体会到了没有分层开发模式的缺陷呢？是否碰到过这样的情况呢？这都是由设计不合理造成的，多层开发架构的出现可以很好地解决该问题，通过程序架构进行合理的分层，将极大地提高程序的通用性。 3. 使用三层架构开发的优点使用三层架构开发有以下优点： 从开发角度和应用角度来看，三层架构比二层架构或单层架构都有更大的优势。三层架构适合团队开发，每人可以有不同的分工，协同工作使效率倍增。开发二层或单层应用程序时，每个开发人员都应对系统有较深的理解，能力要求很高，开发三层应用程序时，则可以结合多方面的人才，只需少数人对系统全面了解即可，从一定程度降低了开发的难度。 三层架构可以更好的支持分布式计算环境。逻辑层的应用程序可以在多个计算机上运行，充分利用网络的计算功能。分布式计算的潜力巨大，远比升级CPU有效。美国人曾利用分式计算解密，几个月就破解了据称永远都破解不了的密码。 三层架构的最大优点是它的安全性。用户只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。 4. 三层架构的种类目前，团队开发人员在开发项目时，大多都使用分层开发架构设计，最常见的就是三层架构，目的在于使各个层之间只能够被它相邻的层产生影响，但是这个限制常常在使用多层开发的时候被违反，这对系统的开发是有害的。三层架构按驱动模式可划分三种：数据层驱动模式、陈述层驱动模式和隔离驱动模式，其中隔离驱动模式开发最为重要。下面通过三种模式的对比，介绍隔离驱动模式的重要性。 数据层驱动模式 所谓的数据层驱动模式，就是先设计数据层，陈述层围绕数据层展开，一旦完成了数据层和陈述层，业务层就围绕数据层展开。因为陈述层是围绕数据层展开的，这将会使陈述层中的约束不准确，并且限制了业务层的变更。由于业务层受到限制，一些简单变化可以通过SQL查询和存储过程来实现。 这种模式非常的普遍，它和传统的客户服务端开发相似，并且是围绕已经存在的数据库设计的。由于陈述层是围绕数据层设计的，它常常是凭直觉模仿数据层的实际结构。 常常存在一种额外的反馈循环在陈述层到数据之间，当在设计陈述层不容易实现的时候常常会去修改数据层，也就形成了这种反馈循环。开发者请求修改数据库方便陈述层的开发，但是对数据层的设计却是有害的。这种改变是人为的而没考虑到其他需求的限制。这种修改经常会违反至少损害数据的特有规则，导致不必要的数据冗余和数据的非标准化。 陈述层驱动模式 陈述层驱动模式是数据层围绕陈述层展开的。业务层的完成一般是通过简单的SQL查询和很少的变化或者隔离。由于数据库的设计是为了陈述层的方便，并非从数据层设计方面考虑，所以数据库的设计在性能上通常很低。 隔离驱动模式 用隔离驱动模式设计，陈述层和数据层被独立的开发，常常是平行开发。这两层在设计时没有任何的相互干扰，所以不会存在人为的约束和有害的设计元素。当两层都设计完成后，再设计业务层。业务层的责任就是在没有对数据层和陈述层的需求变化的基础上完成所有的转换。 因为现在陈述层和数据层是完全独立的，当业务层需求改变的时候，陈述层和数据层都可以做相应的修改而不影响对方。改变两个在物理上不相邻的层不会直接对其他层产生影响或发生冲突。这就允许数据层结构的调整或者陈述层根据用户的需求做相应的变化，而不需要系统做大的调整或者修改。下表将对这3种驱动模式进行对比。 数据层驱动模式 陈述层驱动模式 隔离驱动模式 数据库 1. 很容易设计2.产生负面影响3.很难改变数据层，因为它和陈述层紧密绑定 1.数据库设计很糟2.严重的不规范化设计3.其他系统不易使用4.很难改变数据层，由于它跟陈述层紧密绑定 1.优化设计2.集中设计数据库，陈述层对它影响很小 业务需求 常常不能适应业务需求变化 常常适应业务需求变化 适应需求变化 用户界面 是围绕数据层而不是围绕用户，不易修改 适合用户扩展界面 适合用户扩展界面 扩展性 通常可扩张，但是常常在用户界面需要比较多的重写以满足数据库的结构，同时数据库可能需要存储一些冗余的字段 完整性的扩张很难，常常只有通过“剪切，粘贴”函数来实现 很容易扩展 综上所述，很容易看出隔离驱动模式的优点，隔离驱动模式设计可以极大地提高程序的扩展性。","categories":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/架构/"},{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/系统/"},{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/软件/"}]},{"title":"学习使用Markdown","slug":"Markdown","date":"2018-09-06T07:46:35.000Z","updated":"2018-10-23T05:58:05.686Z","comments":true,"path":"Markdown.html","link":"","permalink":"http://yoursite.com/Markdown.html","excerpt":"1 关于MarkdownMarkdown是一种轻量级标记语言，它的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的HTML(或XHTML)”。 优点 易读 易读是指Markdown文件（即 .md 文件）容易阅读，与HTML相比，它没有各种繁杂的尖括号&lt;&gt;和缩进。整体简洁美观。 易写 使用Markdown可以让你专注于文字，不用像office软件一样需要用鼠标疯狂点击那些排版按钮，可以做到手不离键盘且快速高效的将写作与排版一气呵成。而且Markdown语法简单，花半个小时就能学会基本语法。","text":"1 关于MarkdownMarkdown是一种轻量级标记语言，它的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的HTML(或XHTML)”。 优点 易读 易读是指Markdown文件（即 .md 文件）容易阅读，与HTML相比，它没有各种繁杂的尖括号&lt;&gt;和缩进。整体简洁美观。 易写 使用Markdown可以让你专注于文字，不用像office软件一样需要用鼠标疯狂点击那些排版按钮，可以做到手不离键盘且快速高效的将写作与排版一气呵成。而且Markdown语法简单，花半个小时就能学会基本语法。 缺点 标准不统一 目前Markdown语法众多、编辑器层出不穷，每个编辑器支持的语法也不同，这就导致在一个编辑器上写的md文件，放到其它编辑器上，出现排版混乱，甚至是不支持某些语法的现象。这就是人们所说的 “方言现象”，这也是目前Markdown最突出的问题。 图片支持不够 不能直接显示图片，不能调整大小。且不同编辑器对图片的处理也有所不同。 表格支持不够 原生的Markdown是不支持表格的，但现在大部分编辑器都支持简单的表格，也有支持复杂表格的语法，但是书写困难，且不被大多数编辑器支持。 占用特殊字符 Markdown的语法占用了一些特殊字符，导致想在文本中输入特殊字符的时候，需要进行转义操作。 使用群体 喜欢写博客的人 经常阅读书写各种技术文档的技术人员 混迹于各种技术论坛和社区的程序员 追求简洁排版、快速编辑的文字工作者 2 基本语法2.1 标题只需要在文本前面加上 # 号即可(注意#号后面有一个空格)，二级标题加两个 ## ，三级标题加三个 ### ，以此类推，最多六级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下： 2.2 列表1. 无序列表使用 *，+，- 表示无序列表。列表可以嵌套，上一级和下一级之间敲三个空格即可，建议相同级别的列表项使用相同的符号，并且保持缩进一致，如一级列表用 *，二级列表用 +，三级列表用 - 。 （注意后面需要加空格） 示例： 1234567* 无序列表项1 + 无序列表项1.1 - 无序列表项1.1.1 + 无序列表项1.2 - 无序列表项1.2.1* 无序列表项2* 无序列表项3 效果如下： 无序列表项1 无序列表项1.1 无序列表项1.1.1 无序列表项1.2 无序列表项1.2.1 无序列表项2 无序列表项3 2. 有序列表使用数字和点表示有序列表。（注意后面需要加空格） 示例： 1231. 有序列表项2. 有序列表项3. 有序列表项 效果如下： 有序列表项 有序列表项 有序列表项 2.3 字体1234*斜体***加粗*****斜体加粗***~~删除线~~ 效果如下： 斜体 加粗 斜体加粗 删除线 2.4 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，貌似可以一直嵌套下去。 1234&gt; 引用&gt;&gt; 引用&gt;&gt;&gt; 引用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用 效果如下： 引用 引用 引用 引用 2.5 分割线使用三个或三个以上的 - 或 *。示例： 1234-----------*********** 效果如下： 2.6 超链接加入超链接的格式如下： 1[链接名字](链接地址, &quot;链接title&quot;) 其中链接title可以不填。例如： 1[百度一下](https://www.baidu.com/) 注意：不能直接写成 www.baidu.com ，需要加 https://或http:// 效果如下：百度一下 2.7 插入图片插入图片的格式如下： 1![图片描述](图片地址) 其中图片title可以不填。例如： 1![tree](http://hru.com/blog/180910/84.jpg?imageim) 效果如下： 一般情况下，我们插入的图片大小都不一样，如果像上面的图片一样过大，就会铺满整个屏幕，显示效果就会大打折扣。可惜Markdown没有能处理图片大小的语法（Markdown只注重文字，不注重精细的排版）。天无绝人之路，好在Markdown支持内嵌HTML语句，可以使用HTML来实现图片大小的控制。语法如下： 123&lt;img src=\"http://hru.com/blog/180910/84.jpg?imageim\" width=30% height=30%&gt;width：宽度比例 height：高度比例。width和height也可以填写具体数值 效果如下： 如果有使用七牛作为图床的同学，可以查看七牛API文档，他们提供了更多形式的图片处理接口，这里不做过多介绍。 2.8 表格下面是一般表格的书写格式： 1234表头|表头|表头---|---|---内容|内容|内容内容|内容|内容 表的两边可以加 | 将表包围起来，也可以不加，效果一样，如下所示： 1234|表头|表头|表头||---|---|---||内容|内容|内容||内容|内容|内容| Markdown默认表的内容是左对齐，标题是居中对齐，我们可以根据需要，使用 : 来进行对齐。示例： 123456789左对齐|居中|右对齐:---|:---:|---:内容|内容|内容内容|内容|内容&quot;-&quot;短线每一栏加1个就够了，这里为了对齐，都加了3个。左边加&quot;:&quot;表示文字居左。两边加&quot;:&quot;表示文字居中。右边加&quot;:&quot;表示文字居右。 效果如下： 左对齐标题 居中标题 右对齐标题 内容 内容 内容 内容 内容 内容 2.9 代码Markdown可以内嵌代码，还支持代码高亮，不同开发语言有不同的高亮形式。 语法如下： 1234567891011单行代码使用两个 ` 将代码包围起来：&gt; `代码`多行代码使用两个 ``` 加代码语言标识：&gt; (``` 语言标识)&gt; 代码块&gt; (```)上面的括号和&gt;不用写，这里为了方便展示多加了，请忽略 语言标识是对各种语言的分类，如：python，c，bash，java，php，sql…… 效果如下： 单行代码： unsigned int a; 多行代码(语言标识：C)：123456int main()&#123; int a = 9; printf(\"%d\\n\", a); return 0;&#125; 2.10 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：12345678- [ ] 一级任务 - [ ] 二级任务 - [x] 二级任务 - [x] 二级任务 - [x] 三级任务 - [x] 三级任务- [ ] 一级任务 - [ ] 二级任务 效果如下： 一级任务 二级任务 二级任务 二级任务 三级任务 三级任务 一级任务 二级任务 2.11 修改文字颜色和格式我们写文章的时候，可能需要强调一些文字（颜色、大小、字体等），让读者引起注意，但是Markdown里面没有修改文字颜色的语法，这就需要用HTML语法来实现修改文字颜色。语法如下： 12345678910&lt;font 格式&gt; 文字内容 &lt;/font&gt;其中，“格式”的语法如下：更改颜色：color=#FF0000 //色号是十六进制的更改字体：face=\"宋体\"更改大小：size= 5例如：&lt;font face=\"宋体\"&gt;这段文字是宋体&lt;/font&gt;&lt;font color=#FF0000 face=\"黑体\" size=30&gt;这段文字是红色，黑体，大小30&lt;/font&gt; 这段文字是宋体这段文字是红色，黑体，大小30 3、支持Markdown语法的软件或网站编辑软件： atom —— 21世纪黑客文本编辑器，里面有各种插件，程序猿专用软件，也是我目前在用的编辑软件。 Visual Studio Code —— 一心想要统治地球的软件，对Markdown语法要求严格，经常会出现红波浪线和绿波浪线。 MarkdownPad —— 一款全功能的编辑器，被很多人称赞为windows 平台最好用的markdown编辑器。 Sublime Text 2 —— 界面简约大方，定位专业。 Smark MdCharm 网站（在线编辑器）： 简书 —— 一个很好的博客平台，简约美观，写文章时可以直接拖入图片生成链接。 dillinger —— 支持md, html, pdf 文件导出。支持dropbox, onedrive，google drive, github. Cmd Markdown 小书匠编辑器 如果上面没有适合你的编辑器，请自行上网查找其它的编辑器。","categories":[{"name":"语言","slug":"语言","permalink":"http://yoursite.com/categories/语言/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]}]}
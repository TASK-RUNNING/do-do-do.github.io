{"meta":{"title":"Melville's blog","subtitle":"个人博客","description":"改革春风吹满地","author":"Melville","url":"https://do-do-do.github.io"},"pages":[{"title":"","date":"2018-09-05T07:25:14.000Z","updated":"2019-01-07T08:59:37.777Z","comments":false,"path":"about/index.html","permalink":"https://do-do-do.github.io/about/index.html","excerpt":"","text":"为中华之崛起而读书"},{"title":"404","date":"2019-01-07T08:42:26.000Z","updated":"2019-01-07T08:45:43.446Z","comments":true,"path":"404/index.html","permalink":"https://do-do-do.github.io/404/index.html","excerpt":"","text":"&lt;!DOCTYPE HTML&gt;"},{"title":"分类","date":"2018-09-05T07:20:09.000Z","updated":"2019-01-02T06:48:40.213Z","comments":false,"path":"categories/index.html","permalink":"https://do-do-do.github.io/categories/index.html","excerpt":"","text":""},{"title":"<font face=\"华文行楷\" size=6>留言板</font>","date":"2019-01-07T07:26:50.000Z","updated":"2019-01-07T09:02:11.669Z","comments":true,"path":"message/index.html","permalink":"https://do-do-do.github.io/message/index.html","excerpt":"","text":"有问题，多沟通，欢迎留言~~"},{"title":"日程表","date":"2019-01-02T06:39:37.000Z","updated":"2019-01-07T09:02:23.917Z","comments":false,"path":"schedule/index.html","permalink":"https://do-do-do.github.io/schedule/index.html","excerpt":"","text":"2019年1月8日——复习各种链表的基本操作。 2019年1月7日——给博客新增404公益界面。"},{"title":"标签","date":"2018-09-05T07:22:10.000Z","updated":"2019-01-02T06:47:31.520Z","comments":false,"path":"tags/index.html","permalink":"https://do-do-do.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"史上最全hexo+GitHubPages搭建个人博客","slug":"史上最全hexo-GitHub-Pages搭建个人博客","date":"2019-01-08T06:12:57.000Z","updated":"2019-01-10T02:48:17.218Z","comments":false,"path":"史上最全hexo-GitHub-Pages搭建个人博客.html","link":"","permalink":"https://do-do-do.github.io/史上最全hexo-GitHub-Pages搭建个人博客.html","excerpt":"","text":"前言反反复复搞了很多天，终于搭建好自己的博客了，因为要配置的个性化东西很多，而且网上查找的结果都是比较零散的，所以我搭建博客时浪费了很多时间，也走了很多的坑。为了节约大家的时间，方便大家搭建自己的博客，特地记录下搭建的过程。如果大家在搭建过程中有什么疑问，欢迎留言，同时也请大家收藏网站，防止自己忘记!!! 1. GitHub Pages和hexo简介 GitHub Pages旨在从GitHub存储库托管您的个人，组织或项目页面，是为您和您的项目快速发布漂亮网站的最佳方式。使用GitHub Pages搭建个人网站，可以省去购买服务器、域名等一系列费用，搭建起来非常简单。而且可以上传网页的源代码、更改网页的样式，全部在自己的掌控之中。 Hexo 是一款基于Node.js的快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。依赖少易于安装使用，是搭建博客的首选框架。 2. 创建GitHub Pages2.1 注册GitHub如果你看到这篇文章，90%的可能性已经是GitHub会员了，这里就不介绍注册步骤了，GitHub入口。 2.2 创建仓库进入GitHub个人页面，点击右上角的 + 号新建仓库。 在新建仓库页面，输入仓库名字，选择pulic和初始化README，点击 Create repository 新建仓库，如下图所示。 注意：仓库名字一定要和自己的用户名一样，规则就是 用户名.github.io。不这样命名会出错。创建完成后，在个人仓库页面会出现刚才创建的仓库，点击仓库名称进入仓库。进入仓库后，点击Settings，往下翻，查看仓库的GitHub Pages，已经分配了一个网址，这个网址就是你的博客地址，可以访问。# 3. 安装工具并设置## 3.1 安装Git，关联自己的远程仓库Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。Git是一个工具，GitHub是用于托管项目的网站，不要搞混淆了。 Git下载地址下载并安装完成后，鼠标右键点击桌面（或文件系统的其它地方），会出现 Git GUI Here, Git Bash Here 两个选项。点击 Git Bash Here，打开命令窗口。输入以下指令设置Git用户信息。12git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;生成ssh密钥文件1ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;输入这个命令时会提示一些信息，直接三次回车即可，然后在 C:\\Users\\用户名\\.ssh 目录下会生成两个文件 id_rsa 和 id_rsa.pub。 id_rsa是私钥文件，id_rsa.pub是公钥文件。将 id_rsa.pub用记事本打开，拷贝文件里面的所有内容。 然后打开GitHub个人主页，点击右上角的头像，选择Settings找到 SSH and GPG keys，点击 New SSH key。输入标题和key的内容，点击 Add SSH key在Git Bash中检测GitHub公钥设置是否成功，输入1ssh git@github.com结果如下图所示，则说明设置成功&gt; GitHub添加SSH key的目的：通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了SSH，当你推送的时候，Git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。## 3.2 clone远程仓库到本地不克隆仓库也可以正常部署博客，这一步的目的是为了方便提交本地的配置文件到GitHub上，在 5.2 章节会提到。在本地新建一个空文件夹，克隆刚才新建的仓库1git clone 仓库的URL其中，仓库的URL可从仓库主页获取，如下图：## 3.3 安装node.jsNode.js下载，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js和npm是否安装成功，在命令行中输入12node -v #显示版本号则说明安装成功npm -v #显示版本号则说明安装成功## 3.4 安装hexo进入我们在 3.2 章节中创建的文件夹中，按住shift键，右击鼠标点击命令行（或者是powershell，都是一样的）。输入1npm install -g hexo-cli开始安装hexo，注意，安装hexo以及下面对hexo初始化的操作，一定要在刚才创建的文件夹中进行。 4. 初始化博客以及常用命令hexo安装完成后，开始对其进行初始化1hexo init 初始化的过程稍微有点长，需要等待一会儿。初始化完成之后，文件夹下面应该有这些文件测试一下，依次输入12hexo ghexo s 打开浏览器，输入 localhost:4000，回车，出现OK，博客搭建已经完成一半了，接下来我先介绍几个常用的命令 命令 简写 描述 备注 hexo init [folder] - 在指定目录初始化博客 如果不加[folder]参数，则默认在当前目录初始化 hexo clean - 清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo generate hexo g 生成静态文件 - hexo deploy hexo d 部署网站 可以和hexo g合并成 hexo g -d，生成静态网页并部署网站，用的比较多 hexo version hexo -v 查看hexo版本 - hexo new [layout] [filename] - 新建一篇文章 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 hexo publish [layout] [filename] - 发表草稿 - hexo server hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/ 加参数-p，可以指定端口号 hexo list [type] - 列出网站指定类型的资料 type类型可以是 page, post, route, tag, category等 5. GitHub Pages和hexo关联5.1 更改hexo站点配置文件打开文件夹下面的_config.yml文件翻到最后，填写配置，其中repo可以在你新建的仓库中获取到， 注意:号后面有一个空格。如下图所示 5.2 给仓库创建分支这里的branch填的是master，这个master是你建立的github.io仓库的主干，用于存放生成的静态网页，你从自己博客网站上看到的东西都是在master这个主干上，而我们本地存放的不仅有博客文章，还有网站的配置文件，这就引发了一个问题，如果我们的电脑硬盘坏了，这些配置文件就丢了，我们再想更改网站的配置，就只能从头再来。所以我们要及时对这些文件做好备份，最好的方法当然是备份到GitHub上，我们可以在master的基础上创建一个分支，比如叫hexo，把网站的配置文件都放在hexo分支上，如果我们电脑硬盘坏了或者想换电脑了，直接从hexo分支上pull到本地即可。下面是创建的方法： 直接在此处输入hexo，如果没有这个分支，会提示创建，直接回车即可创建hexo分支。如下图所示 点击 branches，将GitHub的默认分支改成hexo创建好以后，就可以将我们本地的文件提交到hexo上了。关于git的命令，大家自己百度学习。123git add . # 添加所有文件git commit -m &quot;描述&quot; # 提交git push origin hexo # push到hexo分支上 6. 新建一篇博客，并部署接下来就可以写博客啦，我们先新建一个文章，部署上去看看效果。12hexo new myTestFilehexo g -d 部署完成后，打开你的博客网址：https://用户名.github.io，在主页上就能看到你刚才的文章啦。 7. 搭建主题8. 主题配置9. 自定义域名","categories":[{"name":"博客","slug":"博客","permalink":"https://do-do-do.github.io/categories/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://do-do-do.github.io/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"https://do-do-do.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://do-do-do.github.io/tags/next/"}]},{"title":"Windows10企业版激活方法","slug":"Windows10企业版激活方法","date":"2019-01-07T09:52:13.000Z","updated":"2019-01-09T06:22:47.762Z","comments":true,"path":"Windows10企业版激活方法.html","link":"","permalink":"https://do-do-do.github.io/Windows10企业版激活方法.html","excerpt":"","text":"1. 效果图 2. 激活方法以管理员身份运行命令提示符，依次输入以下命令： a. 卸载产品秘钥1slmgr.vbs /upk b. 安装产品秘钥1slmgr /ipk NPPR9-FWDCX-D2C8J-H872K-2YT43 c. 设置计算机名称1slmgr /skms zh.us.to d. 激活1slmgr /ato 3. 查看上述步骤完成后，如果提示成功激活，应该可以从控制面板-&gt;系统和安全-&gt;系统中看到激活状态，如果还是未激活，关机重启后再查看。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://do-do-do.github.io/categories/Windows/"}],"tags":[{"name":"激活","slug":"激活","permalink":"https://do-do-do.github.io/tags/激活/"},{"name":"Windows10","slug":"Windows10","permalink":"https://do-do-do.github.io/tags/Windows10/"}]},{"title":"SublimeText3激活码","slug":"SublimeText3激活码","date":"2019-01-07T09:46:40.000Z","updated":"2019-01-07T09:50:46.533Z","comments":true,"path":"SublimeText3激活码.html","link":"","permalink":"https://do-do-do.github.io/SublimeText3激活码.html","excerpt":"","text":"1. SublimeText3激活码version 3.1.1，build 3176 12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------","categories":[{"name":"工具","slug":"工具","permalink":"https://do-do-do.github.io/categories/工具/"}],"tags":[{"name":"SublimeText3","slug":"SublimeText3","permalink":"https://do-do-do.github.io/tags/SublimeText3/"},{"name":"激活","slug":"激活","permalink":"https://do-do-do.github.io/tags/激活/"}]},{"title":"VMwareWorkstation15Pro激活秘钥","slug":"VMwareWorkstation15Pro激活秘钥","date":"2019-01-07T09:20:09.000Z","updated":"2019-01-07T09:41:36.540Z","comments":true,"path":"VMwareWorkstation15Pro激活秘钥.html","link":"","permalink":"https://do-do-do.github.io/VMwareWorkstation15Pro激活秘钥.html","excerpt":"","text":"1. 激活秘钥123456YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8UG5J2-0ME12-M89WY-NPWXX-WQH88UA5DR-2ZD4H-089FY-6YQ5T-YPRX6GA590-86Y05-4806Y-X4PEE-ZV8E0ZF582-0NW5N-H8D2P-0XZEE-Z22VAYA18K-0WY8P-H85DY-L4NZG-X7RAD 2. 永不过期","categories":[{"name":"工具","slug":"工具","permalink":"https://do-do-do.github.io/categories/工具/"}],"tags":[{"name":"激活","slug":"激活","permalink":"https://do-do-do.github.io/tags/激活/"},{"name":"VMwareWorkstation","slug":"VMwareWorkstation","permalink":"https://do-do-do.github.io/tags/VMwareWorkstation/"},{"name":"秘钥","slug":"秘钥","permalink":"https://do-do-do.github.io/tags/秘钥/"}]},{"title":"iptables和firewalled的区别","slug":"iptables和firewalled的区别","date":"2018-10-23T02:15:57.000Z","updated":"2019-01-04T06:56:01.786Z","comments":true,"path":"iptables和firewalled的区别.html","link":"","permalink":"https://do-do-do.github.io/iptables和firewalled的区别.html","excerpt":"","text":"简述保证数据的安全性是继可用性之后最为重要的一项工作，防火墙技术作为公网与内网之间的保护屏障，起着至关重要的作用。面对同学们普遍不了解在红帽RHEL7系统中新旧两款防火墙的差异，刘遄老师决定先带领读者正确的认识在红帽RHEL7系统中firewalld防火墙服务与iptables防火墙服务之间的关系，从理论和事实层面剖析真相。本章节内将会分别使用iptables、firewall-cmd、firewall-config和Tcp_wrappers等防火墙策略配置服务来完成数十个根据真实工作需求而设计的防火墙策略配置实验，让同学们不仅能够熟练的对请求数据包流量进行过滤，还能够基于服务程序进行允许和关闭操作，做到保证Linux系统安全万无一失。 1. 防火墙管理工具保证数据的安全性是继可用性之后最为重要的一项工作，众所周知外部公网相比企业内网更加的“罪恶丛生”，因此防火墙技术作为公网与内网之间的保护屏障，虽然有软件或硬件之分，但主要功能都是依据策略对外部请求进行过滤。防火墙技术能够做到监控每一个数据包并判断是否有相应的匹配策略规则，直到匹配到其中一条策略规则或执行默认策略为止，防火墙策略可以基于来源地址、请求动作或协议等信息来定制，最终仅让合法的用户请求流入到内网中，其余的均被丢弃。 在红帽RHEL7系统中Firewalld服务取代了Iptables服务，对于接触Linux系统比较早或学习过红帽RHEL6系统的读者来讲，突然改用Firewalld服务后确实不免会有些抵触心理，或许会觉得Firewalld服务是一次不小的改变。但其实Iptables服务与Firewalld服务都不是真正的防火墙，它们都只是用来定义防火墙策略功能的“防火墙管理工具”而已，iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。换句话说，当前在Linux系统中其实同时有多个防火墙管理工具共同存在，它们的作用都是为了方便运维人员管理Linux系统的防火墙策略，而咱们只要配置妥当其中一个就足够了。虽然各个工具之间各有优劣特色，但对于防火墙策略的配置思路上是保持一致的，同学们甚至可以不用完全掌握本章节内的知识，而是在这诸多个防火墙管理工具中任选一款来学透即可，完全能够满足日常的工作所需。 2. iptables在较早期的Linux系统中想配置防火墙默认使用的都是iptables防火墙管理命令，而新型Firewalld防火墙管理服务已经被投入使用多年，但还记得刘遄老师在第0章0.6小节里谈到过企业不愿意及时升级的原因吧，于是不论出于什么样的原因，目前市场上还有大量的生产环境中在使用着iptables命令来管理着防火墙的规则策略。虽然明知iptables可能有着即将被“淘汰”的命运，但为了让同学们不必在面试时尴尬以及看完手中这本《Linux就该这么学》书籍后能“通吃”各个版本的Linux系统，刘遄老师觉得还是有必要把这一项技术好好卖力气讲一下，更何况各个工具的配置防火墙策略思路上大体一致，具有很高的相同性及借鉴意义。 2.1 策略与规则链防火墙会从上至下来读取规则策略，一旦匹配到了合适的就会去执行并立即结束匹配工作，但也有转了一圈之后发现没有匹配到合适规则的时候，那么就会去执行默认的策略。因此对防火墙策略的设置无非有两种，一种是“通”，一种是“堵”——当防火墙的默认策略是拒绝的，就要设置允许规则，否则谁都进不来了，而如果防火墙的默认策略是允许的，就要设置拒绝规则，否则谁都能进来了，起不到防范的作用。 iptables命令把对数据进行过滤或处理数据包的策略叫做规则，把多条规则又存放到一个规则链中，规则链是依据处理数据包位置的不同而进行的分类，包括有：在进行路由选择前处理数据包（PREROUTING）、处理流入的数据包（INPUT）、处理流出的数据包（OUTPUT）、处理转发的数据包（FORWARD）、在进行路由选择后处理数据包（POSTROUTING）。从内网向外网发送的数据一般都是可控且良性的，因此显而易见咱们使用最多的就是INPUT数据链，这个链中定义的规则起到了保证私网设施不受外网骇客侵犯的作用。 比如您所居住的社区物业保安有两条规定——“禁止小商贩进入社区，各种车辆都需要登记”，这两条安保规定很明显应该是作用到了社区的正门（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序规则，咱们可以猜想有多种情况——比如来访人员是小商贩，则会被物业保安直接拒绝在大门外，也无需再对车辆进行登记，而如果来访人员是一辆汽车，那么因为第一条禁止小商贩策略就没有被匹配到，因而按顺序匹配到第二条策略，需要对车辆进行登记，再有如果来访的是社区居民，则既不满足小商贩策略，也不满足车辆登记策略，因此会执行默认的放行策略。 不过只有规则策略还不能保证社区的安全，物业保安还应该知道该怎么样处理这些被匹配到的流量，比如包括有“允许”、“登记”、“拒绝”、“不理他”，这些动作对应到iptables命令术语中是ACCEPT（允许流量通过）、LOG（记录日志信息）、REJECT（拒绝流量通过）、DROP（拒绝流量通过）。允许动作和记录日志工作都比较好理解，着重需要讲解的是这两条拒绝动作的不同点，其中REJECT和DROP的动作操作都是把数据包拒绝，DROP是直接把数据包抛弃不响应，而REJECT会拒绝后再回复一条“您的信息我已收到，但被扔掉了”，让对方清晰的看到数据被拒绝的响应。就好比说您有一天正在家里看电视，突然有人敲门，透过“猫眼”一看是推销商品的，咱们如果不需要的情况下就会直接拒绝他们（REJECT）。但如果透过“猫眼”看到的是债主带了几十个小弟来讨债，这种情况不光要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP），这就是两种拒绝动作的不同之处。 把Linux系统设置成REJECT拒绝动作策略后，对方会看到本机的端口不可达的响应： 12345678[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.From 192.168.10.10 icmp_seq=1 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=2 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=3 Destination Port UnreachableFrom 192.168.10.10 icmp_seq=4 Destination Port Unreachable--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3002ms 把Linux系统设置成DROP拒绝动作策略后，对方会看到本机响应超时的提醒，无法判断流量是被拒绝，还是对方主机当前不在线： 12345[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, 100% packet loss, time 3000ms 2.2 基本的命令参数iptables是一款基于命令行的防火墙策略管理工具，由于该命令是基于终端执行且存在有大量参数的，学习起来难度还是较大的，好在对于日常控制防火墙策略来讲，您无需深入的了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，以便于能够更顺畅的胜任工作所需。iptables命令可以根据数据流量的源地址、目的地址、传输协议、服务类型等等信息项进行匹配，一旦数据包与策略匹配上后，iptables就会根据策略所预设的动作来处理这些数据包流量，另外再来提醒下同学们防火墙策略的匹配顺序规则是从上至下的，因此切记要把较为严格、优先级较高的策略放到靠前位置，否则有可能产生错误。下表中为读者们总结归纳了几乎所有常用的iptables命令参数，刘遄老师遵循《Linux就该这么学》书籍的编写初衷而设计了大量动手实验，让您无需生背硬记这些参数，可以结合下面的实例来逐个参阅即可。 参数 作用 -P 设置默认策略:iptables -P INPUT (DROP&#124;ACCEPT) -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D num 删除某一条规则 -s 匹配来源地址IP/MASK，加叹号”!”表示除这个IP外。 -d 匹配目标地址 -i 网卡名称 匹配从这块网卡流入的数据 -o 网卡名称 匹配从这块网卡流出的数据 -p 匹配协议,如tcp,udp,icmp –dport num 匹配目标端口号 –sport num 匹配来源端口号 -j 指定动作类型 使用iptables命令-L参数查看已有的防火墙策略： 1234567891011[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT all -- anywhere anywhere ctstate RELATED,ESTABLISHEDACCEPT all -- anywhere anywhere INPUT_direct all -- anywhere anywhere INPUT_ZONES_SOURCE all -- anywhere anywhere INPUT_ZONES all -- anywhere anywhere ACCEPT icmp -- anywhere anywhere REJECT all -- anywhere anywhere reject-with icmp-host-prohibited………………省略部分输出信息……………… 使用iptables命令-F参数清空已有的防火墙策略： 12345[root@linuxprobe ~]# iptables -F[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ………………省略部分输出信息……………… 把INPUT链的默认策略设置为拒绝： 如前面所提到的防火墙策略设置无非有两种方式，一种是“通”，一种是“堵”，当把INPUT链设置为默认拒绝后，就要往里面写入允许策略了，否则所有流入的数据包都会被默认拒绝掉，同学们需要留意规则链的默认策略拒绝动作只能是DROP，而不能是REJECT。 12345[root@linuxprobe ~]# iptables -P INPUT DROP[root@linuxprobe ~]# iptables -LChain INPUT (policy DROP)target prot opt source destination …………省略部分输出信息……………… 向INPUT链中添加允许icmp数据包流入的允许策略： 在日常运维工作中经常会使用到ping命令来检查对方主机是否在线，而向防火墙INPUT链中添加一条允许icmp协议数据包流入的策略就是默认允许了这种ping命令检测行为。 123456789101112131415[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.--- 192.168.10.10 ping statistics ---4 packets transmitted, 0 received, 100% packet loss, time 3000ms[root@linuxprobe ~]# iptables -I INPUT -p icmp -j ACCEPT[root@linuxprobe ~]# ping -c 4 192.168.10.10PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.64 bytes from 192.168.10.10: icmp_seq=1 ttl=64 time=0.156 ms64 bytes from 192.168.10.10: icmp_seq=2 ttl=64 time=0.117 ms64 bytes from 192.168.10.10: icmp_seq=3 ttl=64 time=0.099 ms64 bytes from 192.168.10.10: icmp_seq=4 ttl=64 time=0.090 ms--- 192.168.10.10 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 2999msrtt min/avg/max/mdev = 0.090/0.115/0.156/0.027 ms 删除INPUT链中的那条策略，并把默认策略还原为允许： 123456[root@linuxprobe ~]# iptables -D INPUT 1[root@linuxprobe ~]# iptables -P INPUT ACCEPT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination………………省略部分输出信息……………… 设置INPUT链只允许指定网段访问本机的22端口，拒绝其他所有主机的数据请求流量： 防火墙策略是按照从上至下顺序匹配的，因此请一定要记得把允许动作放到拒绝动作上面，否则所有的流量就先被拒绝掉了，任何人都获取不到咱们的业务。文中提到的22端口是下面第9章节讲的ssh服务做占用的资源，刘遄老师在这里挖个小坑~等读者们稍后学完再回来验证这个实验效果吧~ #屏蔽单个IP的命令是iptables -I INPUT -s 123.45.6.7 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令iptables -I INPUT -s 123.0.0.0/8 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令是iptables -I INPUT -s 123.45.6.0/24 -j DROP #指定几个ip123.45.6.0，123.45.6.1,能用ssh连接，其他均不行。iptables -I INPUT -s 123.45.6.0/123.45.6.2 -p tcp -j ACCEPT 1iptables -A INPUT -p tcp --dport 22 -j REJECT 12345678[root@linuxprobe ~]# iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 22 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息……………… 使用IP地址在192.168.10.0/24网段内的主机访问服务器的22端口： 12345678[root@Client A ~]# ssh 192.168.10.10The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.root@192.168.10.10's password: Last login: Sun Feb 12 01:50:25 2017[root@Client A ~]# 使用IP地址在192.168.20.0/24网段外的主机访问服务器的22端口： 123[root@Client B ~]# ssh 192.168.10.10Connecting to 192.168.10.10:22...Could not connect to '192.168.10.10' (port 22): Connection failed. 向INPUT链中添加拒绝所有人访问本机12345端口的防火墙策略： 12345678910[root@linuxprobe ~]# iptables -I INPUT -p tcp --dport 12345 -j REJECT[root@linuxprobe ~]# iptables -I INPUT -p udp --dport 12345 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息……………… 向INPUT链中添加拒绝来自于指定192.168.10.5主机访问本机80端口（web服务）的防火墙策略： 12345678910[root@linuxprobe ~]# iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachable………………省略部分输出信息……………… 向INPUT链中添加拒绝所有主机不能访问本机1000至1024端口的防火墙策略： 12345678910111213[root@linuxprobe ~]# iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT[root@linuxprobe ~]# iptables -A INPUT -p udp --dport 1000:1024 -j REJECT[root@linuxprobe ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination REJECT tcp -- 192.168.10.5 anywhere tcp dpt:http reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpt:italk reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpt:italk reject-with icmp-port-unreachableACCEPT tcp -- 192.168.10.0/24 anywhere tcp dpt:sshREJECT tcp -- anywhere anywhere tcp dpt:ssh reject-with icmp-port-unreachableREJECT tcp -- anywhere anywhere tcp dpts:cadlock2:1024 reject-with icmp-port-unreachableREJECT udp -- anywhere anywhere udp dpts:cadlock2:1024 reject-with icmp-port-unreachable………………省略部分输出信息……………… 是不是还意犹未尽？但对于iptables防火墙管理命令的学习到此就可以结束了，考虑到以后防火墙的发展趋势，同学们只要能把上面的实例看懂看熟就可以完全搞定日常的iptables防火墙配置工作了。但请特别留意下，iptables命令配置的防火墙规则默认会在下一次重启时失效，所以如果您想让配置的防火墙策略永久的生效下去，还要执行一下保存命令： 12[root@linuxprobe ~]# service iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables: [ OK ] 3. firewalledRHEL7是一个集合多款防火墙管理工具并存的系统，Firewalld动态防火墙管理器服务（Dynamic Firewall Manager of Linux systems）是目前默认的防火墙管理工具，同时拥有命令行终端和图形化界面的配置工具，即使是对Linux命令并不熟悉的同学也能快速入门。相比于传统的防火墙管理工具还支持了动态更新技术并加入了“zone区域”的概念，简单来说就是为用户预先准备了几套防火墙策略集合（策略模板），然后可以根据生产场景的不同而选择合适的策略集合，实现了防火墙策略之间的快速切换。例如咱们有一台笔记本电脑每天都要在办公室、咖啡厅和家里使用，按常理推断最安全的应该是家里的内网，其次是公司办公室，最后是咖啡厅，如果需要在办公室内允许文件共享服务的请求流量、回到家中需要允许所有的服务，而在咖啡店则是除了上网外不允许任何其他请求，这样的需求应该是很常见的，在以前只能频繁的进行手动设置，而现在只需要预设好zone区域集合，然后轻轻点击一下就可以切换过去了上百条策略了，极大的提高了防火墙策略的应用效率，常见的zone区域名称及应用可见下表（默认为public）： 区域 默认规则策略 trusted 允许所有的数据包。 home 拒绝流入的数据包，除非与输出流量数据包相关或是ssh,mdns,ipp-client,samba-client与dhcpv6-client服务则允许。 internal 等同于home区域 work 拒绝流入的数据包，除非与输出流量数据包相关或是ssh,ipp-client与dhcpv6-client服务则允许。 public 拒绝流入的数据包，除非与输出流量数据包相关或是ssh,dhcpv6-client服务则允许。 external 拒绝流入的数据包，除非与输出流量数据包相关或是ssh服务则允许。 dmz 拒绝流入的数据包，除非与输出流量数据包相关或是ssh服务则允许。 block 拒绝流入的数据包，除非与输出流量数据包相关。 drop 拒绝流入的数据包，除非与输出流量数据包相关。 3.1 终端管理工具前面第2章学习Linux命令时刘遄老师提到过的，命令行终端是一种极富效率的工作方式，firewall-cmd命令是Firewalld动态防火墙管理器服务的命令行终端。它的参数一般都是以“长格式”来执行的，但同学们也不用太过于担心，因为红帽RHEL7系统非常酷的支持了部分命令的参数补齐，也正好包括了这条命令，也就是说现在除了能够用Tab键来补齐命令或文件名等等内容，还可以用Tab键来补齐下列长格式参数啦（这点特别的棒）。 参数 作用 –get-default-zone 查询默认的区域名称。 –set-default-zone=&lt;区域名称&gt; 设置默认的区域，永久生效。 –get-zones 显示可用的区域。 –get-services 显示预先定义的服务。 –get-active-zones 显示当前正在使用的区域与网卡名称。 –add-source= 将来源于此IP或子网的流量导向指定的区域。 –remove-source= 不再将此IP或子网的流量导向某个指定区域。 –add-interface=&lt;网卡名称&gt; 将来自于该网卡的所有流量都导向某个指定区域。 –change-interface=&lt;网卡名称&gt; 将某个网卡与区域做关联。 –list-all 显示当前区域的网卡配置参数，资源，端口以及服务等信息。 –list-all-zones 显示所有区域的网卡配置参数，资源，端口以及服务等信息。 –add-service=&lt;服务名&gt; 设置默认区域允许该服务的流量。 –add-port=&lt;端口号/协议&gt; 允许默认区域允许该端口的流量。 –remove-service=&lt;服务名&gt; 设置默认区域不再允许该服务的流量。 –remove-port=&lt;端口号/协议&gt; 允许默认区域不再允许该端口的流量。 –reload 让“永久生效”的配置规则立即生效，覆盖当前的。 –panic-on 开启应急状况模式。 –panic-off 关闭应急状况模式。 与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。如果想让配置策略一直存在，就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数，这样配置的防火墙策略就可以永久生效了。但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。 接下来的实验都很简单，但是提醒大家一定要仔细查看刘遄老师使用的是Runtime模式还是Permanent模式。如果不关注这个细节，就算是正确配置了防火墙策略，也可能无法达到预期的效果。 查看firewalld服务当前所使用的区域： 12[root@linuxprobe ~]# firewall-cmd --get-default-zonepublic 查询eno16777728网卡在firewalld服务中的区域： 12[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728public 把firewalld服务中eno16777728网卡的默认区域修改为external，并在系统重启后生效。分别查看当前与永久模式下的区域名称： 123456[root@linuxprobe ~]# firewall-cmd --permanent --zone=external --change-interface=eno16777728success[root@linuxprobe ~]# firewall-cmd --get-zone-of-interface=eno16777728public[root@linuxprobe ~]# firewall-cmd --permanent --get-zone-of-interface=eno16777728external 把firewalld服务的当前默认区域设置为public： 1234[root@linuxprobe ~]# firewall-cmd --set-default-zone=publicsuccess[root@linuxprobe ~]# firewall-cmd --get-default-zone public 启动/关闭firewalld防火墙服务的应急状况模式，阻断一切网络连接（当远程控制服务器时请慎用）： 1234[root@linuxprobe ~]# firewall-cmd --panic-onsuccess[root@linuxprobe ~]# firewall-cmd --panic-offsuccess 查询public区域是否允许请求SSH和HTTPS协议的流量： 1234[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=sshyes[root@linuxprobe ~]# firewall-cmd --zone=public --query-service=httpsno 把firewalld服务中请求HTTPS协议的流量设置为永久允许，并立即生效： 123456[root@linuxprobe ~]# firewall-cmd --zone=public --add-service=httpssuccess[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-service=httpssuccess[root@linuxprobe ~]# firewall-cmd --reloadsuccess 把firewalld服务中请求HTTP协议的流量设置为永久拒绝，并立即生效： 1234[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --remove-service=http success[root@linuxprobe ~]# firewall-cmd --reload success 把在firewalld服务中访问8080和8081端口的流量策略设置为允许，但仅限当前生效： 1234[root@linuxprobe ~]# firewall-cmd --zone=public --add-port=8080-8081/tcpsuccess[root@linuxprobe ~]# firewall-cmd --zone=public --list-ports 8080-8081/tcp 把原本访问本机888端口的流量转发到22端口，要且求当前和长期均有效： 流量转发命令格式为firewall-cmd –permanent –zone=&lt;区域&gt; –add-forward-port=port=&lt;源端口号&gt;:proto=&lt;协议&gt;:toport=&lt;目标端口号&gt;:toaddr=&lt;目标IP地址&gt; 1234[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=888:proto=tcp:toport=22:toaddr=192.168.10.10success[root@linuxprobe ~]# firewall-cmd --reloadsuccess 在客户端使用ssh命令尝试访问192.168.10.10主机的888端口： 1234567[root@client A ~]# ssh -p 888 192.168.10.10The authenticity of host '[192.168.10.10]:888 ([192.168.10.10]:888)' can't be established.ECDSA key fingerprint is b8:25:88:89:5c:05:b6:dd:ef:76:63:ff:1a:54:02:1a.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '[192.168.10.10]:888' (ECDSA) to the list of known hosts.root@192.168.10.10's password:此处输入远程root管理员的密码Last login: Sun Jul 19 21:43:48 2017 from 192.168.10.10 firewalld中的富规则表示更细致、更详细的防火墙策略配置，它可以针对系统服务、端口号、源地址和目标地址等诸多信息进行更有针对性的策略配置。它的优先级在所有的防火墙策略中也是最高的。比如，我们可以在firewalld服务中配置一条富规则，使其拒绝192.168.10.0/24网段的所有用户访问本机的ssh服务（22端口）： 1234[root@linuxprobe ~]# firewall-cmd --permanent --zone=public --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.10.0/24\" service name=\"ssh\" reject\"success[root@linuxprobe ~]# firewall-cmd --reloadsuccess 在客户端使用ssh命令尝试访问192.168.10.10主机的ssh服务（22端口）： 123[root@client A ~]# ssh 192.168.10.10Connecting to 192.168.10.10:22...Could not connect to '192.168.10.10' (port 22): Connection failed. 3.2 图形管理工具在各种版本的Linux系统中，几乎没有能让刘遄老师欣慰并推荐的图形化工具，但是firewall-config做到了。它是firewalld防火墙配置管理工具的GUI（图形用户界面）版本，几乎可以实现所有以命令行来执行的操作。毫不夸张的说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 7中的防火墙策略。firewall-config的界面如图8-2所示，其功能具体如下。 1：选择运行时（Runtime）模式或永久（Permanent）模式的配置。2：可选的策略集合区域列表。3：常用的系统服务列表。4：当前正在使用的区域。5：管理当前被选中区域中的服务。6：管理当前被选中区域中的端口。7：开启或关闭SNAT（源地址转换协议）技术。8：设置端口转发策略。9：控制请求icmp服务的流量。10：管理防火墙的富规则。11：管理网卡设备。12：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。13：firewall-config工具的运行状态。 刘遄老师再啰嗦几句。在使用firewall-config工具配置完防火墙策略之后，无须进行二次确认，因为只要有修改内容，它就自动进行保存。下面进行动手实践环节。 我们先将当前区域中请求http服务的流量设置为允许，但仅限当前生效。具体配置如图8-3所示。 尝试添加一条防火墙策略规则，使其放行访问8080～8088端口（TCP协议）的流量，并将其设置为永久生效，以达到系统重启后防火墙策略依然生效的目的。在按照图8-4所示的界面配置完毕之后，还需要在Options菜单中单击Reload Firewalld命令，让配置的防火墙策略立即生效（见图8-5）。这与在命令行中执行–reload参数的效果一样。 前面在讲解firewall-config工具的功能时，曾经提到了SNAT（Source Network Address Translation，源网络地址转换）技术。SNAT是一种为了解决IP地址匮乏而设计的技术，它可以使得多个内网中的用户通过同一个外网IP接入Internet。该技术的应用非常广泛，甚至可以说我们每天都在使用，只不过没有察觉到罢了。比如，当我们通过家中的网关设备（比如无线路由器）访问本书配套站点www.linuxprobe.com时，就用到了SNAT技术。 大家可以看一下在网络中不使用SNAT技术（见图8-6）和使用SNAT技术（见图8-7）时的情况。在图8-6所示的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。在图8-7所示的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。 使用iptables命令实现SNAT技术是一件很麻烦的事情，但是在firewall-config中却是小菜一碟了。用户只需按照图8-8进行配置，并选中Masquerade zone复选框，就自动开启了SNAT技术。 为了让大家直观查看不同工具在实现相同功能的区别，这里使用firewall-config工具重新演示了前面使用firewall-cmd来配置防火墙策略规则，将本机888端口的流量转发到22端口，且要求当前和长期均有效，具体如图8-9和图8-10所示。 配置富规则，让192.168.10.20主机访问到本机的1234端口号，如图8-11所示。 如果生产环境中的服务器有多块网卡在同时提供服务（这种情况很常见），则对内网和对外网提供服务的网卡要选择的防火墙策略区域也是不一样的。也就是说，可以把网卡与防火墙策略区域进行绑定（见图8-12），这样就可以使用不同的防火墙区域策略，对源自不同网卡的流量进行针对性的监控，效果会更好。 最后，刘遄老师想说的是，firewall-config工具真的非常实用，很多原本复杂的长命令被用图形化按钮替代，设置规则也简单明了，足以应对日常工作。所以再次向大家强调配置防火墙策略的原则—只要能实现所需的功能，用什么工具请随君便。 4. 服务的访问控制列表TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。 TCP Wrappers服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。 TCP Wrappers服务的控制列表文件配置起来并不复杂，常用的参数如表4所示。 表4 TCP Wrappers服务的控制列表文件中常用的参数 客户端类型 示例 满足示例的客户端列表 单一主机 192.168.10.10 IP地址为192.168.10.10的主机 指定网段 192.168.10. IP段为192.168.10.0/24的主机 指定网段 192.168.10.0/255.255.255.0 IP段为192.168.10.0/24的主机 指定DNS后缀 .linuxprobe.com 所有DNS后缀为.linuxprobe.com的主机 指定主机名称 www.linuxprobe.com 主机名称为www.linuxprobe.com的主机 指定所有客户端 ALL 所有主机全部包括在内 在配置TCP Wrappers服务时需要遵循两个原则： 编写拒绝策略规则时，填写的是服务名称，而非协议名称； 建议先编写拒绝策略规则，再编写允许策略规则，以便直观地看到相应的效果。 下面编写拒绝策略规则文件，禁止访问本机sshd服务的所有流量（无须/etc/hosts.deny文件中修改原有的注释信息）： 12345678910111213141516[root@linuxprobe ~]# vim /etc/hosts.deny## hosts.deny This file contains access rules which are used to# deny connections to network services that either use# the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## The rules in this file can also be set up in# /etc/hosts.allow with a 'deny' option instead.## See 'man 5 hosts_options' and 'man 5 hosts_access'# for information on rule syntax.# See 'man tcpd' for information on tcp_wrapperssshd:*[root@linuxprobe ~]# ssh 192.168.10.10ssh_exchange_identification: read: Connection reset by peer 接下来，在允许策略规则文件中添加一条规则，使其放行源自192.168.10.0/24网段，访问本机sshd服务的所有流量。可以看到，服务器立刻就放行了访问sshd服务的流量，效果非常直观： 1234567891011121314151617181920[root@linuxprobe ~]# vim /etc/hosts.allow## hosts.allow This file contains access rules which are used to# allow or deny connections to network services that# either use the tcp_wrappers library or that have been# started through a tcp_wrappers-enabled xinetd.## See 'man 5 hosts_options' and 'man 5 hosts_access'# for information on rule syntax.# See 'man tcpd' for information on tcp_wrapperssshd:192.168.10.[root@linuxprobe ~]# ssh 192.168.10.10The authenticity of host '192.168.10.10 (192.168.10.10)' can't be established.ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '192.168.10.10' (ECDSA) to the list of known hosts.root@192.168.10.10's password: Last login: Wed May 4 07:56:29 2017[root@linuxprobe ~]#","categories":[{"name":"Linux系统","slug":"Linux系统","permalink":"https://do-do-do.github.io/categories/Linux系统/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://do-do-do.github.io/tags/linux/"},{"name":"网络","slug":"网络","permalink":"https://do-do-do.github.io/tags/网络/"},{"name":"防火墙","slug":"防火墙","permalink":"https://do-do-do.github.io/tags/防火墙/"}]},{"title":"Linux下用iperf测试网络时出现unable to connect to server: No route to host","slug":"Linux下用iperf测试网络时出现unable-to-connect-to-server-No-route-to-host","date":"2018-10-23T01:27:01.000Z","updated":"2019-01-04T06:56:08.807Z","comments":true,"path":"Linux下用iperf测试网络时出现unable-to-connect-to-server-No-route-to-host.html","link":"","permalink":"https://do-do-do.github.io/Linux下用iperf测试网络时出现unable-to-connect-to-server-No-route-to-host.html","excerpt":"","text":"Problem为了验证虚拟网卡驱动的性能，需要两台主机之间互相收发数据，我使用iperf工具进行测试，报错“unable to connect to server: No route to host”，但是可以ping通另一台主机。 SolventGoogle了一下，发现是防火墙的问题，需要将防火墙关掉，大部分搜索到的结果都是： 12service iptables stopiptables -F 执行此操作后并没有解决问题（我用的是中标麒麟V5.0系统），我就把系统防火墙firewalld全部关闭，问题解决。指令如下：1234systemctl stop firewalldsystemctl disable firewalldsystemctl stop firewalld.servicesystemctl disable firewalld.service 想知道iptables和firewalled有什么区别？请参照《iptables和firewalled的区别》","categories":[{"name":"工具","slug":"工具","permalink":"https://do-do-do.github.io/categories/工具/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://do-do-do.github.io/tags/linux/"},{"name":"网络","slug":"网络","permalink":"https://do-do-do.github.io/tags/网络/"},{"name":"iperf","slug":"iperf","permalink":"https://do-do-do.github.io/tags/iperf/"}]},{"title":"C语言结构体中char[0]和char[1]的用法","slug":"C语言结构体中char-0-和char-1-的用法","date":"2018-09-18T09:45:22.000Z","updated":"2019-01-07T08:40:44.316Z","comments":true,"path":"C语言结构体中char-0-和char-1-的用法.html","link":"","permalink":"https://do-do-do.github.io/C语言结构体中char-0-和char-1-的用法.html","excerpt":"","text":"1.写在前面我在进行Linux 64位驱动程序兼容32位应用程序的适配过程中，深深的感觉指针操作带来的麻烦，特别是应用层的32位指针传到内核层后，指针大小变成64位，需要进行频繁的大小调整，及其难受。等我快完成所有工作的时候，听一位同事说可以使用char[0]用法来代替指针，我差点一口老血喷出来。“你咋不早说…”。接下来从网上各种google，发现了这种用法的巧妙，特写下此篇文章，以做记录。（PS：还是要感谢我那位同事YYL，让我又get到一个技能^_^） 在结构体最后加char[0]或char[1]的用法是GNU C的扩展，在ISO/IEC 9899-1999里面，这么写是非法的。这种用法在C99中叫做 柔性数组。柔性数组成员前面必须至少有一个其它类型成员。包含柔性数组成员的结构要用malloc进行动态内存分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。 2.引用这种用法的目的 主要是为了方便管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）而如果使用数组，那么只需要一次就可以全部分配出来，反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序。 其实就是分配一段连续的的内存，减少内存的碎片化。 3.用法1234567struct Msg&#123; ... // 其它成员 ... // 其它成员 int nLen; // 一般char data[0]的前面会加一个长度nLen表示data的大小 char data[0]; // char[0]或char[1]必须放在最后&#125;; 我们要知道的一点就是：char data[0] 这个数组是没有元素的，它的地址紧跟着nLen后的地址，如果分配的内存大于结构体的实际大小，那么大出来的那部分就是data的内容。 实际使用时，一般这样用 123int dataBytes = 10; // 此处指定data的数据大小struct Msg *p = (struct Msg *)malloc(sizeof(struct Msg) + dataBytes); // 动态分配p-&gt;nLen = dataBytes; // 把长度赋值给nLen，以方便其它部分使用此结构体 如果还不明白，撸一串代码，一看便知： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// test.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct body1&#123; int a; int b;&#125;__attribute ((packed)) BODY1; //__attribute ((packed))是强制不进行字节对齐typedef struct body2&#123; int len; char *data;&#125;__attribute ((packed)) BODY2;typedef struct body3&#123; int len; char data[0];&#125;__attribute ((packed)) BODY3;typedef struct body4&#123; int len; char data[1];&#125;__attribute ((packed)) BODY4;int main()&#123; BODY1 b1; BODY2 b2; BODY3 b3; BODY4 b4; memset(&amp;b1, 0, sizeof(BODY1)); memset(&amp;b2, 0, sizeof(BODY2)); memset(&amp;b3, 0, sizeof(BODY3)); memset(&amp;b4, 0, sizeof(BODY4)); printf(\"sizeof(b1) = %ld\\n\", sizeof(b1)); printf(\"sizeof(b2) = %ld\\n\", sizeof(b2)); printf(\"sizeof(b3) = %ld\\n\", sizeof(b3)); printf(\"sizeof(b4) = %ld\\n\", sizeof(b4)); printf(\" b2 addr = %p\\n\", &amp;b2); printf(\"b2.data addr = %p\\n\", b2.data); printf(\" b3 addr = %p\\n\", &amp;b3); printf(\"b3.data addr = %p\\n\", b3.data); printf(\" b4 addr = %p\\n\", &amp;b4); printf(\"b4.data addr = %p\\n\", b4.data); return 0;&#125; 程序是在64位系统下编译，运行结果如下: 12345678910sizeof(b1) = 8sizeof(b2) = 12sizeof(b3) = 4sizeof(b4) = 5 b2 addr = 0x7ffded4f3633b2.data addr = (nil) b3 addr = 0x7ffded4f363fb3.data addr = 0x7ffded4f3643 b4 addr = 0x7ffded4f3643b4.data addr = 0x7ffded4f3647 从上面的结果可以看出： char data[0]是不占用任何空间的，而char *data占用了一个指针变量的大小，千万不要把char data[0]当做一个指针，它其实是一个偏移量，这个偏移量指向结构体后紧挨着的空间。 char[1]是占用空间的，如果没加强制不进行字节对齐，则结构体的大小会是8。char[0]和char[1]的作用是相同的。 b3的data地址，是b3结构体开始的地址加上len所占用的4字节的地址，b4也是一样。 4.用指针和char[0]的区别 结构体中使用指针：创建时，系统先为结构体分配内存，再分配指针指向的data的内存。两块内存不连续。释放的时候，先释放指针指向的内存，再释放结构体内存。 结构体中使用char[0]：创建时，系统一起为其分配结构体的内存和data的内存，两块内存是连续的（更确切的说是一块内存）。释放的时候，一次性释放。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://do-do-do.github.io/categories/编程语言/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://do-do-do.github.io/tags/C语言/"},{"name":"结构体","slug":"结构体","permalink":"https://do-do-do.github.io/tags/结构体/"},{"name":"指针","slug":"指针","permalink":"https://do-do-do.github.io/tags/指针/"},{"name":"内存","slug":"内存","permalink":"https://do-do-do.github.io/tags/内存/"}]},{"title":"Linux64位系统兼容32位应用程序","slug":"Linux64位系统兼容32位应用程序","date":"2018-09-18T09:21:40.000Z","updated":"2019-01-04T06:56:05.441Z","comments":true,"path":"Linux64位系统兼容32位应用程序.html","link":"","permalink":"https://do-do-do.github.io/Linux64位系统兼容32位应用程序.html","excerpt":"","text":"1. 问题现象在进行64位驱动兼容32位应用程序的修改中，发现了如下几个问题： 32位应用程序调用ioctl时，返回ENOTTY（inappropriate ioctl for device）错误。经过调试发现根本没调用到内核的ioctl函数。 解决完第一个问题后，应用程序进入了ioctl中，但是用户程序和驱动打印的ioctl命令号不一样，导致在switch的时候，找不到对应命令号。 从用户空间拷贝数据的时候（copy_from_user()）失败。拷贝的数据结构里面含有指针。 2. 问题分析2.1 第一个问题在 Linux kernel 2.6.36 中已经完全删除了 struct file_operations 结构中的 ioctl 函数指针，取而代之的是 unlocked_ioctl。之后的内核版本中，struct file_operations 含有下面两个函数指针： 123456struct file_operations &#123; ... ... long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); ... ...&#125;； 如果是64位用户程序运行在64位的内核上，调用的是unlocked_ioctl; 如果是32位用户程序运行在32位的内核上，调用的也是unlocked_ioctl; 支持64位的驱动必须要实现compat_ioctl，如果没有实现，那么32位的用户程序在64位的内核上执行ioctl时会返回错误 ENOTTY。 要解决第一个问题，就需要在驱动层实现 compat_ioctl. 2.2 第二个问题命令号中的参数部分含有指针，32位用户程序的指针是4字节，64位驱动的指针是8字节，导致最终计算出的命令号不一致。可采用如下方法解决： 尽量避免使用指针类型 提供64位和32位大小一致的结构 先将传入的指针转成64位，使其能进入ioctl函数，在函数内部再对指针进行处理。 2.3 第三个问题由于传入内核的数据结构里面含有指针类型，所以在拷贝的时候，用户态结构和内核态结构的大小就不一样，导致拷贝失败。解决方法如下： 使用compat_ptr()宏转换64位的unsigned long数据类型到32位的地址。 对ioctl函数的参数也要使用compat_ptr()进行转换。 避免使用指针，可用 char[0] 或 char[1] 代替。关于char[0] 和 char[1]的用法，参照这篇文章。","categories":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://do-do-do.github.io/categories/Linux驱动/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://do-do-do.github.io/tags/linux/"},{"name":"驱动","slug":"驱动","permalink":"https://do-do-do.github.io/tags/驱动/"},{"name":"兼容","slug":"兼容","permalink":"https://do-do-do.github.io/tags/兼容/"}]},{"title":"三层架构：表示层——业务逻辑层——数据访问层","slug":"三层架构","date":"2018-09-12T02:58:00.000Z","updated":"2019-01-04T06:56:29.482Z","comments":true,"path":"三层架构.html","link":"","permalink":"https://do-do-do.github.io/三层架构.html","excerpt":"","text":"1. 什么是三层架构所谓的三层开发就是将系统的整个业务应用划分为 表示层,业务逻辑层,数据访问层，这样有利于系统的开发、维护、部署和扩展。分层是为了实现 “高内聚，低耦合”，采用 “分而治之” 的思想，把问题划分开来各个解决，易于控制、易于延展、易于分配资源。进行软件开发设计，一定要懂得 分而治之 分而治之 分而治之 表示层：负责直接跟用户进行交互，一般也就是指系统的界面，用于数据录入，数据显示等。意味着只做与外观显示相关的工作，不属于他的工作不用做。 业务逻辑层：用于做一些有效的验证工作，以更好地保证程序运行的健壮性。如完成数据添加、修改和查询等；不允许指定的文本框中输入空字符串，数据格式是否正确及数据类型验证；用户的权限合法性判断等。通过以上诸多判断以决定是否将操作继续向后传递，尽量保证程序的正常运行。 数据访问层：顾名思义，就是专门跟数据库进行交互，执行数据的添加、删除、修改和显示等。需要强调的是，所有的数据对象只在这一层被引用，除数据层之外的任何地方都不应该出现这样的引用。 ASP.NET可以使用.NET平台快速方便地部署三层架构。ASP.NET革命性的变化是在网页中也使用基于事件的处理，可以指定处理的后台代码文件，可以使用C#、VB、C++和J#作为后台代码的语言。.NET中可以方便的实现组件的装配，后台代码通过命名空间可以方便的使用自己定义的组件。显示层放在ASPX页面中，数据库操作和逻辑层用组件或封装类来实现，这样就很方便的实现了三层架构。 2. 为什么使用三层架构对于一个简单的应用程序来说，代码量不是很多的情况下，一层结构或二层结构开发完全够用，没有必要将其复杂化，如果对一个复杂的大型系统，设计为一层结构或二层结构开发，那么这样的设计存在很严重缺陷。下面会具体介绍，分层开发其实是为大型系统服务的。 在开发过程中，初级程序人员出现相似的功能经常复制代码，那么同样的代码为什么要写那么多次？不但使程序变得冗长，更不利于维护，一个小小的修改或许会涉及很多页面，经常导致异常的产生使程序不能正常运行。最主要的面向对象的思想没有得到丝毫的体现，打着面向对象的幌子却依然走着面向过程的道路。 意识到这样的问题，初级程序人员开始将程序中一些公用的处理程序写成公共方法，封装在类中，供其他程序调用。例如写一个数据操作类，对数据操作进行合理封装，在数据库操作过程中，只要类中的相应方法（数据添加、修改、查询等）可以完成特定的数据操作，这就是数据访问层，不用每次操作数据库时都写那些重复性的数据库操作代码。在新的应用开发中，数据访问层可以直接拿来用。面向对象的三大特性之一的封装性在这里得到了很好的体现。读者现在似乎找到了面向对象的感觉，代码量较以前有了很大的减少，而且修改的时候也比较方便，也实现了代码的重用性。 下面举两个案例，解释一下为什么要使用三层架构。 案例一： 数据库系统软件由于数据量的不断增加，数据库由Access变成了SQLServer数据库，这样原来的数据访问层失效了，数据操作对象发生了变化，并且页面中涉及数据对象的地方也要进行修改，因为原来可能会使用OleDbDataReader对象将数据传递给显示页面，现在都得换成SqlDataReader对象，SQLServer和Access支持的数据类型也不一致，在显示数据时进行的数据转换也要进行修改，这是其中一种情况。 案例二： 由于特殊情况需要，把Web形式的项目改造成Windows应用，此时需要做多少修改呢？如果在Aspx.cs中占据了大量代码，或者还有部分代码存在于Aspx中，那么整个系统是否需要重新来开发呢？ 在上面的案例中是否体会到了没有分层开发模式的缺陷呢？是否碰到过这样的情况呢？这都是由设计不合理造成的，多层开发架构的出现可以很好地解决该问题，通过程序架构进行合理的分层，将极大地提高程序的通用性。 3. 使用三层架构开发的优点使用三层架构开发有以下优点： 从开发角度和应用角度来看，三层架构比二层架构或单层架构都有更大的优势。三层架构适合团队开发，每人可以有不同的分工，协同工作使效率倍增。开发二层或单层应用程序时，每个开发人员都应对系统有较深的理解，能力要求很高，开发三层应用程序时，则可以结合多方面的人才，只需少数人对系统全面了解即可，从一定程度降低了开发的难度。 三层架构可以更好的支持分布式计算环境。逻辑层的应用程序可以在多个计算机上运行，充分利用网络的计算功能。分布式计算的潜力巨大，远比升级CPU有效。美国人曾利用分式计算解密，几个月就破解了据称永远都破解不了的密码。 三层架构的最大优点是它的安全性。用户只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。 4. 三层架构的种类目前，团队开发人员在开发项目时，大多都使用分层开发架构设计，最常见的就是三层架构，目的在于使各个层之间只能够被它相邻的层产生影响，但是这个限制常常在使用多层开发的时候被违反，这对系统的开发是有害的。三层架构按驱动模式可划分三种：数据层驱动模式、陈述层驱动模式和隔离驱动模式，其中隔离驱动模式开发最为重要。下面通过三种模式的对比，介绍隔离驱动模式的重要性。 数据层驱动模式 所谓的数据层驱动模式，就是先设计数据层，陈述层围绕数据层展开，一旦完成了数据层和陈述层，业务层就围绕数据层展开。因为陈述层是围绕数据层展开的，这将会使陈述层中的约束不准确，并且限制了业务层的变更。由于业务层受到限制，一些简单变化可以通过SQL查询和存储过程来实现。 这种模式非常的普遍，它和传统的客户服务端开发相似，并且是围绕已经存在的数据库设计的。由于陈述层是围绕数据层设计的，它常常是凭直觉模仿数据层的实际结构。 常常存在一种额外的反馈循环在陈述层到数据之间，当在设计陈述层不容易实现的时候常常会去修改数据层，也就形成了这种反馈循环。开发者请求修改数据库方便陈述层的开发，但是对数据层的设计却是有害的。这种改变是人为的而没考虑到其他需求的限制。这种修改经常会违反至少损害数据的特有规则，导致不必要的数据冗余和数据的非标准化。 陈述层驱动模式 陈述层驱动模式是数据层围绕陈述层展开的。业务层的完成一般是通过简单的SQL查询和很少的变化或者隔离。由于数据库的设计是为了陈述层的方便，并非从数据层设计方面考虑，所以数据库的设计在性能上通常很低。 隔离驱动模式 用隔离驱动模式设计，陈述层和数据层被独立的开发，常常是平行开发。这两层在设计时没有任何的相互干扰，所以不会存在人为的约束和有害的设计元素。当两层都设计完成后，再设计业务层。业务层的责任就是在没有对数据层和陈述层的需求变化的基础上完成所有的转换。 因为现在陈述层和数据层是完全独立的，当业务层需求改变的时候，陈述层和数据层都可以做相应的修改而不影响对方。改变两个在物理上不相邻的层不会直接对其他层产生影响或发生冲突。这就允许数据层结构的调整或者陈述层根据用户的需求做相应的变化，而不需要系统做大的调整或者修改。下表将对这3种驱动模式进行对比。 数据层驱动模式 陈述层驱动模式 隔离驱动模式 数据库 1. 很容易设计2.产生负面影响3.很难改变数据层，因为它和陈述层紧密绑定 1.数据库设计很糟2.严重的不规范化设计3.其他系统不易使用4.很难改变数据层，由于它跟陈述层紧密绑定 1.优化设计2.集中设计数据库，陈述层对它影响很小 业务需求 常常不能适应业务需求变化 常常适应业务需求变化 适应需求变化 用户界面 是围绕数据层而不是围绕用户，不易修改 适合用户扩展界面 适合用户扩展界面 扩展性 通常可扩张，但是常常在用户界面需要比较多的重写以满足数据库的结构，同时数据库可能需要存储一些冗余的字段 完整性的扩张很难，常常只有通过“剪切，粘贴”函数来实现 很容易扩展 综上所述，很容易看出隔离驱动模式的优点，隔离驱动模式设计可以极大地提高程序的扩展性。","categories":[{"name":"架构","slug":"架构","permalink":"https://do-do-do.github.io/categories/架构/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://do-do-do.github.io/tags/架构/"},{"name":"系统","slug":"系统","permalink":"https://do-do-do.github.io/tags/系统/"},{"name":"软件","slug":"软件","permalink":"https://do-do-do.github.io/tags/软件/"}]},{"title":"学习使用Markdown","slug":"Markdown","date":"2018-09-06T07:46:35.000Z","updated":"2019-01-07T08:17:22.541Z","comments":true,"path":"Markdown.html","link":"","permalink":"https://do-do-do.github.io/Markdown.html","excerpt":"","text":"1 关于MarkdownMarkdown是一种轻量级标记语言，它的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的HTML(或XHTML)”。 优点 易读 易读是指Markdown文件（即 .md 文件）容易阅读，与HTML相比，它没有各种繁杂的尖括号&lt;&gt;和缩进。整体简洁美观。 易写 使用Markdown可以让你专注于文字，不用像office软件一样需要用鼠标疯狂点击那些排版按钮，可以做到手不离键盘且快速高效的将写作与排版一气呵成。而且Markdown语法简单，花半个小时就能学会基本语法。 缺点 标准不统一 目前Markdown语法众多、编辑器层出不穷，每个编辑器支持的语法也不同，这就导致在一个编辑器上写的md文件，放到其它编辑器上，出现排版混乱，甚至是不支持某些语法的现象。这就是人们所说的 “方言现象”，这也是目前Markdown最突出的问题。 图片支持不够 不能直接显示图片，不能调整大小。且不同编辑器对图片的处理也有所不同。 表格支持不够 原生的Markdown是不支持表格的，但现在大部分编辑器都支持简单的表格，也有支持复杂表格的语法，但是书写困难，且不被大多数编辑器支持。 占用特殊字符 Markdown的语法占用了一些特殊字符，导致想在文本中输入特殊字符的时候，需要进行转义操作。 使用群体 喜欢写博客的人 经常阅读书写各种技术文档的技术人员 混迹于各种技术论坛和社区的程序员 追求简洁排版、快速编辑的文字工作者 2 基本语法2.1 标题只需要在文本前面加上 # 号即可(注意#号后面有一个空格)，二级标题加两个 ## ，三级标题加三个 ### ，以此类推，最多六级标题。 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下： 2.2 列表1. 无序列表使用 *，+，- 表示无序列表。列表可以嵌套，上一级和下一级之间敲三个空格即可，建议相同级别的列表项使用相同的符号，并且保持缩进一致，如一级列表用 *，二级列表用 +，三级列表用 - 。 （注意后面需要加空格） 示例： 1234567* 无序列表项1 + 无序列表项1.1 - 无序列表项1.1.1 + 无序列表项1.2 - 无序列表项1.2.1* 无序列表项2* 无序列表项3 效果如下： 无序列表项1 无序列表项1.1 无序列表项1.1.1 无序列表项1.2 无序列表项1.2.1 无序列表项2 无序列表项3 2. 有序列表使用数字和点表示有序列表。（注意后面需要加空格） 示例： 1231. 有序列表项2. 有序列表项3. 有序列表项 效果如下： 有序列表项 有序列表项 有序列表项 2.3 字体1234*斜体***加粗*****斜体加粗***~~删除线~~ 效果如下： 斜体 加粗 斜体加粗 删除线 2.4 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，貌似可以一直嵌套下去。 1234&gt; 引用&gt;&gt; 引用&gt;&gt;&gt; 引用&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用 效果如下： 引用 引用 引用 引用 2.5 分割线使用三个或三个以上的 - 或 *。示例： 1234-----------*********** 效果如下： 2.6 超链接加入超链接的格式如下： 1[链接名字](链接地址, &quot;链接title&quot;) 其中链接title可以不填。例如： 1[百度一下](https://www.baidu.com/) 注意：不能直接写成 www.baidu.com ，需要加 https://或http:// 效果如下：百度一下 2.7 插入图片插入图片的格式如下： 1![图片描述](图片地址) 其中图片title可以不填。例如： 1![tree](http://hru.com/blog/180910/84.jpg?imageim) 效果如下： 一般情况下，我们插入的图片大小都不一样，如果像上面的图片一样过大，就会铺满整个屏幕，显示效果就会大打折扣。可惜Markdown没有能处理图片大小的语法（Markdown只注重文字，不注重精细的排版）。天无绝人之路，好在Markdown支持内嵌HTML语句，可以使用HTML来实现图片大小的控制。语法如下： 123&lt;img src=\"http://hru.com/blog/180910/84.jpg?imageim\" width=30% height=30%&gt;width：宽度比例 height：高度比例。width和height也可以填写具体数值 效果如下： 如果有使用七牛作为图床的同学，可以查看七牛API文档，他们提供了更多形式的图片处理接口，这里不做过多介绍。 2.8 表格下面是一般表格的书写格式： 1234表头|表头|表头---|---|---内容|内容|内容内容|内容|内容 表的两边可以加 | 将表包围起来，也可以不加，效果一样，如下所示： 1234|表头|表头|表头||---|---|---||内容|内容|内容||内容|内容|内容| Markdown默认表的内容是左对齐，标题是居中对齐，我们可以根据需要，使用 : 来进行对齐。示例： 123456789左对齐|居中|右对齐:---|:---:|---:内容|内容|内容内容|内容|内容&quot;-&quot;短线每一栏加1个就够了，这里为了对齐，都加了3个。左边加&quot;:&quot;表示文字居左。两边加&quot;:&quot;表示文字居中。右边加&quot;:&quot;表示文字居右。 效果如下： 左对齐标题 居中标题 右对齐标题 内容 内容 内容 内容 内容 内容 2.9 代码Markdown可以内嵌代码，还支持代码高亮，不同开发语言有不同的高亮形式。 语法如下： 1234567891011单行代码使用两个 ` 将代码包围起来：&gt; `代码`多行代码使用两个 ``` 加代码语言标识：&gt; (``` 语言标识)&gt; 代码块&gt; (```)上面的括号和&gt;不用写，这里为了方便展示多加了，请忽略 语言标识是对各种语言的分类，如：python，c，bash，java，php，sql…… 效果如下： 单行代码： unsigned int a; 多行代码(语言标识：C)：123456int main()&#123; int a = 9; printf(\"%d\\n\", a); return 0;&#125; 2.10 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：12345678- [ ] 一级任务 - [ ] 二级任务 - [x] 二级任务 - [x] 二级任务 - [x] 三级任务 - [x] 三级任务- [ ] 一级任务 - [ ] 二级任务 效果如下： 一级任务 二级任务 二级任务 二级任务 三级任务 三级任务 一级任务 二级任务 2.11 修改文字颜色和格式我们写文章的时候，可能需要强调一些文字（颜色、大小、字体、位置等），让读者引起注意，但是Markdown里面没有修改文字颜色的语法，这就需要用HTML语法来实现修改文字颜色。语法如下： a. 颜色、大小、字体修改12345678910&lt;font 格式&gt; 文字内容 &lt;/font&gt;其中，“格式”的语法如下：更改颜色：color=#FF0000 //色号是十六进制的更改字体：face=\"宋体\"更改大小：size= 5例如：&lt;font face=\"宋体\"&gt;这段文字是宋体&lt;/font&gt;&lt;font color=#FF0000 face=\"黑体\" size=30&gt;这段文字是红色，黑体，大小30&lt;/font&gt; 这段文字是宋体这段文字是红色，黑体，大小30 b. 文字居中1&lt;center&gt; 文字居中 &lt;/center&gt; 这是一段居中的文字 3、支持Markdown语法的软件或网站编辑软件： atom —— 21世纪黑客文本编辑器，里面有各种插件，程序猿专用软件，也是我目前在用的编辑软件。 Visual Studio Code —— 一心想要统治地球的软件，对Markdown语法要求严格，经常会出现红波浪线和绿波浪线。 MarkdownPad —— 一款全功能的编辑器，被很多人称赞为windows 平台最好用的markdown编辑器。 Sublime Text 2 —— 界面简约大方，定位专业。 Smark MdCharm 网站（在线编辑器）： 简书 —— 一个很好的博客平台，简约美观，写文章时可以直接拖入图片生成链接。 dillinger —— 支持md, html, pdf 文件导出。支持dropbox, onedrive，google drive, github. Cmd Markdown 小书匠编辑器 如果上面没有适合你的编辑器，请自行上网查找其它的编辑器。","categories":[{"name":"语言","slug":"语言","permalink":"https://do-do-do.github.io/categories/语言/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://do-do-do.github.io/tags/markdown/"}]}]}